#!/usr/bin/python

# HINT:
#   ssh -L 1389:localhost:389 label
#   ssh -R 1389:localhost:1389 socket


import sys
sys.path.insert(0, '../gitadmin-bin')

import os
import glob
import ldap
import ldap.modlist
import string
from random import choice, randrange
import sha
from base64 import b64encode
import smtplib
from email.MIMEText import MIMEText
import libxml2
import semi_rdf
import urllib

try:
    import xml.etree.cElementTree as et
except ImportError:
    import cElementTree as et

try: import readline
except: pass

def escape_dn_chars(s):
  """
  Escape all DN special characters found in s
  with a back-slash
  """
  if s:
    s = s.replace('\\','\\\\')
    s = s.replace(',' ,'\\,')
    s = s.replace('+' ,'\\+')
    s = s.replace('"' ,'\\"')
    s = s.replace('<' ,'\\<')
    s = s.replace('>' ,'\\>')
    s = s.replace(';' ,'\\;')
    s = s.replace('=' ,'\\=')
    if s[0]=='#':
      s = ''.join(('\\',s))
    if s[-1]==' ':
      s = ''.join((s[:-1],'\\ '))
  return s


def getpass(prompt = "Password: "):
    import termios
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    new = termios.tcgetattr(fd)
    new[3] = new[3] & ~termios.ECHO          # lflags
    try:
        termios.tcsetattr(fd, termios.TCSADRAIN, new)
        passwd = raw_input(prompt)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)
    return passwd


def is_executable(prog):
    if sys.platform == "win32":
        return True
    info = os.stat(prog)
    return (info.st_uid == os.getuid() and (info.st_mode & 0100) or
            info.st_gid == os.getgid() and (info.st_mode & 0010) or
            info.st_mode & 0001)


def find_program(prog):
    path = os.environ.get("PATH", "").split(os.pathsep)

    for directory in path:
        program = os.path.join(directory, prog)
        if os.path.exists(program) and is_executable(program):
            return program
    return ""


def gen_passwd(length=8, chars=string.letters + string.digits):
    return ''.join([choice(chars) for i in range(length)])


def hash_ssha(password):
    salt = ''.join([chr(randrange(0,255)) for i in range(4)])
    ctx = sha.new(password  + salt)
    hash = "{SSHA}" + b64encode(ctx.digest() + salt)
    return hash


CHUNK_SIZE = 16384
def svn_get_file(path, filename, rev=None):
    try:
        repos_ptr = repos.open(path)
    except core.SubversionException:
        return None
    fsob = repos.fs(repos_ptr)

    if rev is None:
        rev = fs.youngest_rev(fsob)

    root = fs.revision_root(fsob, rev)
    try:
        file = fs.file_contents(root, filename)
    except core.SubversionException:
        return None
    d = []
    while 1:
        data = core.svn_stream_read(file, CHUNK_SIZE)
        if not data:
            break
        d.append(data)
    return ''.join(d)

def get_remote_file(url):
    f = urllib.urlopen(url)

    # Ensure the URL is sane (readable and plain text)
    if f.headers.getmaintype() != 'text' or f.headers.status != "":
        return ""

    return f.read()


class Mango(object):

    #LDAP_URL = "ldap://ldap-back:389"
    LDAP_URL = "ldap://localhost:1389"
    LDAP_PASSWD = None
    _ldap = None

    DOAP = "http://usefulinc.com/ns/doap#"
    FOAF = "http://xmlns.com/foaf/0.1/"
    GNOME = "http://api.gnome.org/doap-extensions#"

    GNOME_REPO = 'git://git.gnome.org/'

    EMAIL_TEMPLATE = string.Template("""Hello $cn,

There is a new way to get accounts setup asap. This using a system
called Mango. The new system will directly mail the maintainer(s) of the
responsible module / the language coordinator (you). With this email I'll try
to explain how it will work.

 ==> IF YOU AREN'T INTERESTED IN DETAILS, SEE END OF THE EMAIL FOR YOUR
 ==> PASSWORD

If you missed my blog post regarding Mango, please read/glance:
http://blogs.gnome.org/ovitters/2007/09/26/sneak-preview-of-mango/
(images are cropped, sorry)

Basically the process is as follows:
1. User requests account
2. User verifies email address
3. Mango mails maintainers / l10n coordinators
4. Maintainer/coordinator reject/approve account request
==> can need multiple maintainers if e.g. user requested e.g. Bugzilla
shell account and Git for nautilus.. in practice, this won't happen
5a. Mango mails Accounts Team
5b. Mango mails progress information to the user
6. Accounts Team sets up user in LDAP
7. User gets welcome email

Note: steps 3-4 can be skipped as some requests will directly go to the
accounts team (e.g. @gnome.org alias)


What does not work:
* This is for new accounts. It will not work if the userid already
exists. This is planned for the future (so you can request an additional
group).
* You cannot change your Mango password. Sorry. See end of the email for
how to get your password.
* You cannot change your other details (SSH keys, email address). It is
planned, but can take a while before you see it.
* You cannot change who is maintainer of your modules. This is planned
for the future.
==> If you want to dicuss Mango, please use
gnome-infrastructure@gnome.org mailing list.


How to approve account requests:
* l10n coordinators: Make sure you have read
  http://live.gnome.org/TranslationProject/RequestingAnAccount
* You will get an email from Mango to your email address registered in
LDAP. This is (possibly) different from
http://foundation.gnome.org/membership/members.php!
* Go to https://mango.gnome.org/ and log in (see end of email for
password)
* You will get an overview of outstanding requests right after logging
in. See http://blogs.gnome.org/ovitters/files/2007/09/mango7.png. If
there aren't any outstanding requests, currently it only says something
like "Welcome $NAME" (and a log out button).
* Reject/approve the request(s) and click submit
Note: Because this goes to multiple persons, you might not see the
request even if you got an email from Mango. This means another person
was faster.
==> NOTE: The user will be informed. If you reject a person, please send
an explanation to the user. Ideally before you click submit, because
Mango will email the user right away.


In case of problems:
Please either email gnome-infrastructure@gnome.org, or file a bug:
http://bugzilla.gnome.org/enter_bug.cgi?product=sysadmin&component=mango
(sysadmin product, mango component)


YOUR MANGO PASSWORD
To see your mango password, do:
  ssh -l $uid svn.gnome.org mango

Your username is same as your Git username.

Note: You can only run this command once. The next time it will have
forgotten what your password was.

Note2: For those who want to try out, this allows you to use the jabber
service (jabber.gnome.org, username is same as git/mango/etc). Please
*enforce* SSL/TLS. Do NOT allow plain text auth! However, this is only
intended for foundation members (it'll work currently for everyone, but
that will not be forever). This was setup by Jeff, if it doesn't work,
it probably requires some other setting.""")

    def __init__(self, passwd):
        self.LDAP_PASSWD = passwd

        l = ldap.initialize(Mango.LDAP_URL)
        l.protocol_version = ldap.VERSION3
        l.simple_bind_s("cn=Manager,dc=gnome,dc=org", passwd)

        self._ldap = l
        self._init_ldap_accounts()


    def _init_ldap_accounts(self):
        self.UID_TO_DN = {}
        self.UID_TO_PW = {}
        self.UID_TO_MAIL = {}
        self.UID_TO_CN = {}
        self.UID_TO_NR = {}

        l = self._ldap
        results = l.search_s("dc=gnome,dc=org", ldap.SCOPE_SUBTREE, "objectClass=posixAccount", ('uid', 'cn', 'mail', 'userPassword', 'uidNumber'))
        for entry in results:
            id = entry[0]
            attr = entry[1]

            if 'mail' not in attr: # Make sure it isn't some internal userid
                continue

            uid = attr['uid'][0]
            cn = attr['cn'][0]

            self.UID_TO_DN[uid] = id
            if 'userPassword' in attr:
                self.UID_TO_PW[uid] = attr['userPassword'][0]
            self.UID_TO_CN[uid] = cn
            self.UID_TO_MAIL[uid] = attr['mail'][0].lower().strip()
            self.UID_TO_NR[uid] = int(attr['uidNumber'][0])


    def get_maintainer_data_ldap(self):
        """Get maintainer data from LDAP (cached)"""
        if hasattr(self, '_maint_ldap'):
            return self._maint_ldap

        UID_TO_MODULES = {}
        MODULE_TO_UIDS = {}
        MODULE_TO_DN = {}
        MODULE_TO_DESC = {}

        l = self._ldap
        results = l.search_s("dc=gnome,dc=org", ldap.SCOPE_SUBTREE, "(objectClass=gnomeModule)", ('cn', 'description','maintainerUid'))
        for entry in results:
            id = entry[0]
            attr = entry[1]

            modname = attr['cn'][0]
            uids = attr['maintainerUid']

            MODULE_TO_DN[modname] = id
            MODULE_TO_DESC[modname] = attr['description'][0]
            MODULE_TO_UIDS.setdefault(modname, set()).update(uids)
            for uid in uids:
                UID_TO_MODULES.setdefault(uid, set()).add(modname)

        self._maint_ldap = (UID_TO_MODULES, MODULE_TO_UIDS, MODULE_TO_DESC, MODULE_TO_DN)
        return self._maint_ldap


    def get_vcs_modules(self):
        """Return a list of SVN modules (cached)"""
        if not hasattr(self, 'MODULES'):
            self.MODULES = [mod for mod in glob.glob('/svn/*') if os.path.exists(os.path.join(mod, 'hooks'))]

        return self.MODULES


    def get_maintainer_data_svn(self):
        """Try to find the maintainers of every GNOME SVN repository"""
        UID_TO_MODULES = {}
        MODULE_TO_UIDS = {}
        MODULE_TO_DESC = {}
        INVALID = {}
        ONCE_VALID = {}

        # Get module maintainer data from MAINTAINERS file in Git
        nodes = semi_rdf.read_rdf('http://git.gnome.org/repositories.doap')
        for node in nodes:
            if node.name != (DOAP, "Project"):
                continue

            repo = node.find_property((DOAP, u'repository'))
            modname = None
            if isinstance(repo, semi_rdf.Node):
                repo_loc = repo.find_property((DOAP, u'location'))

                if hasattr(repo_loc, 'startswith') and repo_loc.startswith(GNOME_REPO):
                    modname = repo_loc[len(GNOME_REPO):]

            if not modname:
                continue

            for maint in node.find_properties((DOAP, u'maintainer')):
                if not isinstance(maint, semi_rdf.Node):
                    continue

                uid = maint.find_property((GNOME, u'userid'))
                if uid.__class__.__name__ != "unicode":
                    continue

                is_valid_uid = uid in self.UID_TO_CN
                possible_emails = set(["%s@svn.gnome.org" % uid, "%s@gnome.org" % uid, "%s@cvs.gnome.org" % uid])
                if is_valid_uid:
                    possible_emails.add(self.UID_TO_MAIL[uid])
                spam_1 = [mail.replace('@', ' ').replace('.', ' ') for mail in possible_emails]
                spam_2 = [mail.replace('@', ' at ').replace('.', ' dot ') for mail in possible_emails]
                spam_3 = [mail.replace('@', ' ') for mail in possible_emails]
                spam_4 = [mail.replace('@', ' at ') for mail in possible_emails]

                possible_emails.update(spam_1 + spam_2 + spam_3 + spam_4)
                possible_emails.update(['<%s>' % mail for mail in possible_emails])

                is_valid_email = email in possible_emails

                # XXX - not used/needed: self.MAINTAINERS.setdefault(modname, {})[uid] = [email, name, is_valid_uid, is_valid_email]
                if is_valid_uid:
                    UID_TO_MODULES.setdefault(uid, set()).add(modname)
                    MODULE_TO_UIDS.setdefault(modname, set()).add(uid)
                if not is_valid_uid or not is_valid_email:
                    if uid not in INVALID:
                        INVALID[uid] = [email, name, is_valid_uid, is_valid_email]
                    INVALID[uid].append(modname)
                else:
                    ONCE_VALID[uid] = [email, name, is_valid_uid, is_valid_email]

        return (UID_TO_MODULES, MODULE_TO_UIDS, MODULE_TO_DESC, INVALID, ONCE_VALID)


    def set_passwds(self, uids):
        """Set the password for one or more users"""
        # XXX - should be able to write to /var/local/mango

        PASSWDS = {}
        l = self._ldap

        for uid in uids:
            if uid not in self.UID_TO_CN:
                continue

            passwd = gen_passwd(length=12)
            hash = hash_ssha(passwd)
            PASSWDS[uid] = passwd

            dn = self.UID_TO_DN[uid]
            if uid in self.UID_TO_PW:
                old = {'userPassword': self.UID_TO_PW[uid]}
            else:
                old = {}
            ldif = ldap.modlist.modifyModlist(old, {'userPassword': hash})
            l.modify_s(dn,ldif)
        return PASSWDS


    def store_passwds(self, passwds):
        """Saves the password to files readable only by the intended UID.

        These passwords will be cleared asap."""
        if not passwds: return

        s = smtplib.SMTP()
        s.connect()
        
        try:
            prevmask = os.umask(0177)
                
            for uid, passwd in passwds.iteritems():
                if uid not in self.UID_TO_CN: continue # XXX -- warn loudly
                
                mail = self.UID_TO_MAIL[uid]
                path = '/var/local/mango/%s' % uid
                
                f = file(path, 'w')
                print >>f, passwd
                f.close()
                os.chown(path, self.UID_TO_NR[uid], -1)

                mime = MIMEText(self.EMAIL_TEMPLATE.safe_substitute(
                    uid=uid,
                    mail=mail,
                    cn=self.UID_TO_CN[uid],

                ))
                mime['Subject'] = 'GNOME Mango account: %s' % uid
                mime['From'] = 'Mango <accounts@gnome.org>'
                mime['To'] = mail
                s.sendmail('accounts@gnome.org', [mail], mime.as_string())
        finally:
            os.umask(prevmask)
 

    def update_ldap_modules(self, vcs_modules, svn_descs, change=True, remove=False):
        ldap_uids, ldap_modules, ldap_desc, ldap_dn = self.get_maintainer_data_ldap()
        l = self._ldap

        if not change: remove = False

        for modname in sorted(vcs_modules.keys()):
            dn = ldap_dn.get(modname, 'cn=%s,ou=modules,dc=gnome,dc=org' % escape_dn_chars(modname))
            maints = vcs_modules[modname]

            if modname not in ldap_modules: # add
                entry = {
                    'cn': modname,
                    'sn': modname,
                    'description': svn_descs.get(modname, '%s module' % modname),
                    'maintainerUid': list(vcs_modules[modname])
                }
                
                classes = ['gnomeModule', 'inetOrgPerson']
                # XXX - Fucking ugly hack
                if modname.startswith('l10n-') and modname in svn_descs:
                    classes.append('localizationModule')
                    entry['localizationTeam'] = ' '

                entry['objectClass'] = classes
                

                ldif = ldap.modlist.addModlist(entry)
                if change:
                    l.add_s(dn, ldif)
                else:
                    print dn, ldif
            elif modname in ldap_modules and vcs_modules[modname].symmetric_difference(ldap_modules[modname]):
                ldif = ldap.modlist.modifyModlist({'maintainerUid': list(ldap_modules[modname])},
                                             {'maintainerUid': list(vcs_modules[modname])})
                if change:
                    l.modify_s(dn,ldif)
                else:
                    print dn, ldif

        if not remove: return

        rem_mods = set(ldap_modules.keys()).difference(vcs_modules.keys())

        print "Modules to REALLY remove:"
        print rem_mods
        for modname in rem_mods:
            if modname not in ldap_dn:
                continue
            print ldap_dn[modname]
            
            l.delete_s(ldap_dn[modname]) # XXX - doesn't actually work

        

def usage():
    print "Wrong usage"
    sys.exit(1)


if __name__ == '__main__':
    if len(sys.argv) < 2: usage()

    MANGO_CFG = {}

    cfg_files = ('/var/www/mango/config.xml', '/etc/mango/config.xml')

    import os.path
    for f in cfg_files:
        if os.path.exists(f):
            doc = et.parse(file(f, 'r'))
            root = doc.getroot()
            for el in root.getchildren():
                if el.tag in cfg_opts:
                    MANGO_CFG[el.tag] = el.text
    ········
            break

    LDAP_PASSWD = MANGO_CFG.get('ldap_bindpw', None)
    if 'ldap_url' in MANGO_CFG:
        Mango.LDAP_URL = MANGO_CFG['ldap_url']

    if not LDAP_PASSWD:
        print "Please provide the Manager LDAP password"
        LDAP_PASSWD = getpass('--> ')

    m = Mango(LDAP_PASSWD)

    cmd = sys.argv.pop(1)
    if cmd == 'sync' or cmd == 'show-diffs':
        change_stuff = cmd == 'sync'

        svn_data = m.get_maintainer_data_svn()
#        ldap_data = m.get_maintainer_data_ldap() # UID_TO_MODULES, MODULE_TO_UIDS, MODULE_TO_DESC

#        ul = set(ldap_data[1].keys())
#        us = set(svn_data[1].keys())
        desc_svn = svn_data[2]
        INVALID = svn_data[3]
        ONCE_VALID = svn_data[4]

#        new_mods = us.difference(ul)
#        removed_mods = ul.difference(us)
#        print "New modules:"
#        print sorted(new_mods)
#        print "Removed modules:"
#        print sorted(removed_mods)
#        for modname in us.intersection(ul):
#            mod_added = svn_data[1][modname].difference(ldap_data[1][modname])
#            mod_removed = ldap_data[1][modname].difference(svn_data[1][modname])
#            if len(mod_added) or len(mod_removed):
#                print "Module %s" % modname
#                print sorted(mod_added)
#                print sorted(mod_removed)

        for uid in sorted(INVALID.keys()):
                if uid in ONCE_VALID:
                        continue

                print "\t".join([uid, INVALID[uid][0], m.UID_TO_MAIL.get(uid, '???'), ", ".join(INVALID[uid][4:])])

        #m.update_ldap_modules(svn_data[1], remove=True)
        m.update_ldap_modules(svn_data[1], svn_data[2], change=change_stuff)

        uids_give_passwd = set(svn_data[0].keys()).difference(m.UID_TO_PW.keys())
        if uids_give_passwd:
            print "UIDs to give/reset passwords:"
            print ", ".join(uids_give_passwd)
            if change_stuff:
                passwds = m.set_passwds(uids_give_passwd)
                m.store_passwds(passwds)


    elif cmd == 'test-reset':
        m.store_passwds({'ovitters': 'yeahright'})
    elif cmd == 'reset-passwd':
        uids = []
        for uid in sys.argv[1:]:
            if uid in m.UID_TO_PW:
                uids.append(uid)
        if uids:
            print 'Resetting passwords for: %s' % ', '.join(uids)
            passwds = m.set_passwds(uids)
            m.store_passwds(passwds)
    elif cmd == 'new-passwd':
        uids = []
        for uid in sys.argv[1:]:
            if uid in m.UID_TO_MAIL and uid not in m.UID_TO_PW:
                uids.append(uid)
        if uids:
            print 'Setting new passwords for: %s' % ', '.join(uids)
            passwds = m.set_passwds(uids)
            m.store_passwds(passwds)
    else:
        usage()
    
