#!/usr/bin/python

import sys
import os
import os.path
script_path = os.path.realpath(os.path.abspath(sys.argv[0]))
script_dir = os.path.dirname(script_path) + '/git'
sys.path.insert(0, script_dir)

import glob
import ldap
import ldap.modlist
import ldap.filter
import ldif
import string
from random import choice, randrange
try:
    import hashlib
except ImportError:
    import sha as hashlib
from base64 import b64encode
import smtplib
from email.MIMEText import MIMEText
import libxml2
import semi_rdf
import urllib
import texttable

try:
    import xml.etree.cElementTree as et
except ImportError:
    import cElementTree as et

try: import readline
except: pass

def escape_dn_chars(s):
  """
  Escape all DN special characters found in s
  with a back-slash
  """
  if s:
    s = s.replace('\\','\\\\')
    s = s.replace(',' ,'\\,')
    s = s.replace('+' ,'\\+')
    s = s.replace('"' ,'\\"')
    s = s.replace('<' ,'\\<')
    s = s.replace('>' ,'\\>')
    s = s.replace(';' ,'\\;')
    s = s.replace('=' ,'\\=')
    if s[0]=='#':
      s = ''.join(('\\',s))
    if s[-1]==' ':
      s = ''.join((s[:-1],'\\ '))
  return s


def getpass(prompt = "Password: "):
    import termios
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    new = termios.tcgetattr(fd)
    new[3] = new[3] & ~termios.ECHO          # lflags
    try:
        termios.tcsetattr(fd, termios.TCSADRAIN, new)
        passwd = raw_input(prompt)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)
    return passwd


def is_executable(prog):
    if sys.platform == "win32":
        return True
    info = os.stat(prog)
    return (info.st_uid == os.getuid() and (info.st_mode & 0100) or
            info.st_gid == os.getgid() and (info.st_mode & 0010) or
            info.st_mode & 0001)


def find_program(prog):
    path = os.environ.get("PATH", "").split(os.pathsep)

    for directory in path:
        program = os.path.join(directory, prog)
        if os.path.exists(program) and is_executable(program):
            return program
    return ""


def gen_passwd(length=8, chars=string.letters + string.digits):
    return ''.join([choice(chars) for i in range(length)])


def hash_ssha(password):
    salt = ''.join([chr(randrange(0,255)) for i in range(4)])
    ctx = hashlib.sha1(password  + salt)
    hash = "{SSHA}" + b64encode(ctx.digest() + salt)
    return hash


def get_remote_file(url):
    f = urllib.urlopen(url)

    # Ensure the URL is sane (readable and plain text)
    if f.headers.getmaintype() != 'text' or f.headers.status != "":
        return ""

    return f.read()


class Mango(object):

    #LDAP_URL = "ldap://ldap-back:389"
    LDAP_URL = "ldap://localhost:1389"
    LDAP_PASSWD = None
    _ldap = None

    DOAP = "http://usefulinc.com/ns/doap#"
    FOAF = "http://xmlns.com/foaf/0.1/"
    GNOME = "http://api.gnome.org/doap-extensions#"

    GNOME_REPO = 'git://git.gnome.org/'
    GNOME_FTP = 'http://download.gnome.org/sources/'

    EMAIL_TEMPLATE = string.Template("""Hello $cn,

Mango is the system which people can use to request new GNOME accounts.

You've been added as either a maintainer or a language coordinator. When Mango
asks you to confirm to vouch for someone, you'll need to login to:
  https://mango.gnome.org/

 ==> IF YOU AREN'T INTERESTED IN DETAILS, SEE END OF THE EMAIL FOR YOUR
 ==> PASSWORD

The process for new accounts is:
1. User requests account
2. User verifies email address
3. Mango mails maintainers / l10n coordinators
4. Maintainer/coordinator reject/approve account request
==> can need multiple maintainers if user requested Bugzilla shell account and
    Git for Nautilus. In practice, this should not happen.
5a. Mango mails Accounts Team
5b. Mango mails progress information to the user
6. Accounts Team sets up user in LDAP
7. User gets welcome email

Note: steps 3-4 can be skipped as some requests will directly go to the
accounts team (e.g. @gnome.org alias)


What does not work:
* This is for new accounts. It will not work if the userid already
exists. This is planned for the future (so you can request additional
access/changes).
* You cannot change your other details (SSH keys, email address). It is
planned, but can take a while before you see it.


How to approve account requests:
* l10n coordinators: Make sure you have read
  http://live.gnome.org/TranslationProject/RequestingAnAccount
* You will get an email from Mango to your email address registered in
  LDAP. This could be different than your email address known at
  http://foundation.gnome.org/!
* Go to https://mango.gnome.org/ and log in (see end of email for
  password)
* You will get an overview of outstanding requests right after logging
  in. If there aren't any outstanding requests, currently it only says
  something like "Welcome $NAME" (and a log out button).
* Reject/approve the request(s) and click submit
  Note: Because this goes to multiple persons, you might not see the
  request even if you got an email from Mango. This means another person
  was faster.
==> NOTE: The user will be informed. If you reject a person, please send
          an explanation to the user. Ideally before you click submit,
          because Mango will email the user right away.

YOUR MANGO PASSWORD
To retrieve (reset) your mango password, do:
  ssh -l $uid mango.gnome.org mango
Your username is same as your Git username.


Note2: Your Mango password also allows you to use the jabber service
(jabber.gnome.org, username is same as git/mango/etc). Please *enforce*
SSL/TLS. Do NOT allow plain text auth! However, this is only intended for
foundation members.""")

    def __init__(self, passwd):
        self.LDAP_PASSWD = passwd

        l = ldap.initialize(Mango.LDAP_URL)
        l.protocol_version = ldap.VERSION3
        l.simple_bind_s("cn=Manager,dc=gnome,dc=org", passwd)

        self._ldap = l
        self._init_ldap_accounts()


    def _init_ldap_accounts(self):
        self.UID_TO_DN = {}
        self.UID_TO_PW = {}
        self.UID_TO_MAIL = {}
        self.UID_TO_CN = {}
        self.UID_TO_NR = {}
        self.VCS_UIDS = set(self.get_uids_from_group('gnomecvs') + self.get_uids_from_group('gnomevcs'))
        self.FTPBASIC_UIDS = set(self.get_uids_from_group('ftpbasic'))

        l = self._ldap
        results = l.search_s("dc=gnome,dc=org", ldap.SCOPE_SUBTREE, "objectClass=posixAccount", ('uid', 'cn', 'mail', 'userPassword', 'uidNumber'))
        for entry in results:
            id = entry[0]
            attr = entry[1]

            # Require mail attribute to hopefully exclude system userids
            if 'mail' not in attr:
                continue

            uid = attr['uid'][0]
            cn = attr['cn'][0]

            self.UID_TO_DN[uid] = id
            if 'userPassword' in attr:
                self.UID_TO_PW[uid] = attr['userPassword'][0]
            self.UID_TO_CN[uid] = cn
            self.UID_TO_MAIL[uid] = attr['mail'][0].lower().strip()
            self.UID_TO_NR[uid] = int(attr['uidNumber'][0])


    def get_uids_from_group(self, group):
        l = self._ldap
        filter = ldap.filter.filter_format("(cn=%s)", (group, ))
        try:
            ldap_result_id = l.search ("ou=groups,dc=gnome,dc=org",
                                       ldap.SCOPE_SUBTREE, filter, None)
            while 1:
                result_type, group_data = l.result(ldap_result_id, 0)
                if (group_data == []):
                    break
                else:
                    group_info = group_data[0][1]
                    return group_info.get('memberUid', [])
        except ldap.LDAPError, e:
            print e
            sys.exit(1)

        return []


    def get_maintainer_data_ldap(self):
        """Get maintainer data from LDAP (cached)"""
        if hasattr(self, '_maint_ldap'):
            return self._maint_ldap

        UID_TO_MODULES = {}
        MODULE_TO_UIDS = {}
        MODULE_TO_DN = {}
        MODULE_TO_DESC = {}
        MODULE_TO_TARBALLS = {}

        l = self._ldap
        results = l.search_s("dc=gnome,dc=org", ldap.SCOPE_SUBTREE, "(objectClass=gnomeModule)", ('cn', 'description','maintainerUid','tarballName'))
        for entry in results:
            id = entry[0]
            attr = entry[1]

            modname = attr['cn'][0]
            uids = attr['maintainerUid']
            tarballs = attr.get('tarballName', [])

            MODULE_TO_DN[modname] = id
            MODULE_TO_DESC[modname] = attr['description'][0]
            MODULE_TO_UIDS.setdefault(modname, set()).update(uids)
            MODULE_TO_TARBALLS.setdefault(modname, set()).update(tarballs)
            for uid in uids:
                UID_TO_MODULES.setdefault(uid, set()).add(modname)

        self._maint_ldap = (UID_TO_MODULES, MODULE_TO_UIDS, MODULE_TO_DESC, MODULE_TO_DN, MODULE_TO_TARBALLS, self.FTPBASIC_UIDS)
        return self._maint_ldap


    def get_maintainer_data_vcs(self):
        """Try to find the maintainers of every GNOME vcs repository"""
        UID_TO_MODULES = {}
        MODULE_TO_UIDS = {}
        MODULE_TO_DESC = {}
        INVALID = {}
        ONCE_VALID = {}
        MODULE_TO_TARBALLS = {}

        # Get l10n coordinators from damned-lies
        root = et.fromstring(get_remote_file("http://l10n.gnome.org/teams/?format=xml"))
        for team in root.getchildren():
            team_id = team.get('id')
            uid = team.findtext('coordinator/vcs')

            if team_id is None or uid is None:
                continue

            if uid not in self.UID_TO_CN:
                print "WARNING: Bad damned-lies coordinator: %s" % uid
                continue

            desc = team.findtext('description')
            if desc is None:
                desc = team_id

            modname = 'l10n-%s' % team_id

            MODULE_TO_DESC[modname] = '%s (team %s)' % (desc, team_id)
            UID_TO_MODULES.setdefault(uid, set()).add(modname)
            MODULE_TO_UIDS.setdefault(modname, set()).add(uid)

        # Get module maintainer data from DOAP file in Git
        # Note: some data is still in MAINTAINERS files. These are converted
        #       to DOAP information by scripts in gitadmin-bin module.
        nodes = semi_rdf.read_rdf('http://git.gnome.org/repositories.doap')
        for node in nodes:
            if node.name != (self.DOAP, "Project"):
                continue

            repo = node.find_property((self.DOAP, u'repository'))
            modname = None
            if isinstance(repo, semi_rdf.Node):
                repo_loc = repo.find_property((self.DOAP, u'location'))

                if hasattr(repo_loc, 'startswith') and repo_loc.startswith(self.GNOME_REPO):
                    modname = repo_loc[len(self.GNOME_REPO):]

            if not modname:
                continue

            tarballs = [str(download)[len(self.GNOME_FTP):].split('/')[0] for download in node.find_properties((self.DOAP, u'download-page')) \
                        if isinstance(download, semi_rdf.UrlResource) and str(download).startswith(self.GNOME_FTP)]
            MODULE_TO_TARBALLS.setdefault(modname, set()).update(tarballs)

            for maint in node.find_properties((self.DOAP, u'maintainer')):
                if not isinstance(maint, semi_rdf.Node):
                    continue

                uid = maint.find_property((self.GNOME, u'userid'))
                if not isinstance(uid, basestring):
                    continue

                name = maint.find_property((self.FOAF, u'name'))
                if not isinstance(name, basestring):
                    continue

                email = maint.find_property((self.FOAF, u'mbox'))
                if not isinstance(email, semi_rdf.UrlResource) or not email.startswith('mailto:'):
                    email = '%s@src.gnome.org' % uid
                else:
                    email = email[7:]

                uid = str(uid)
                email = str(email)

                is_valid_uid = uid in self.UID_TO_CN and uid in self.VCS_UIDS
                # Email comparison is done case insensitive. According to the RFC
                # this should only be done for the host part, but in practice it
                # doesn't matter.
                possible_emails = set([
                    "%s@svn.gnome.org" % uid.lower(),
                    "%s@gnome.org" % uid.lower(),
                    "%s@cvs.gnome.org" % uid.lower(),
                    "%s@src.gnome.org" % uid.lower()
                ])
                if is_valid_uid:
                    possible_emails.add(self.UID_TO_MAIL[uid].lower())
                spam_1 = [mail.replace('@', ' ').replace('.', ' ') for mail in possible_emails]
                spam_2 = [mail.replace('@', ' at ').replace('.', ' dot ') for mail in possible_emails]
                spam_3 = [mail.replace('@', ' ') for mail in possible_emails]
                spam_4 = [mail.replace('@', ' at ') for mail in possible_emails]
                spam_5 = [mail.replace('@', '%40') for mail in possible_emails]
                spam_6 = [mail.replace('@', '.') for mail in possible_emails]

                possible_emails.update(spam_1 + spam_2 + spam_3 + spam_4 + spam_5 + spam_6)
                possible_emails.update(['<%s>' % mail for mail in possible_emails])

                is_valid_email = email.lower() in possible_emails

                # XXX - not used/needed: self.MAINTAINERS.setdefault(modname, {})[uid] = [email, name, is_valid_uid, is_valid_email]
                if is_valid_uid:
                    UID_TO_MODULES.setdefault(uid, set()).add(modname)
                    MODULE_TO_UIDS.setdefault(modname, set()).add(uid)
                if not is_valid_uid or not is_valid_email:
                    if uid not in INVALID:
                        INVALID[uid] = {}

                    invalid_data = (is_valid_uid, email, name)
                    if invalid_data not in INVALID[uid]:
                        INVALID[uid][invalid_data] = []

                    INVALID[uid][invalid_data].append(modname)
                else:
                    ONCE_VALID[uid] = [email, name, is_valid_uid, is_valid_email]

        return (UID_TO_MODULES, MODULE_TO_UIDS, MODULE_TO_DESC, MODULE_TO_TARBALLS, INVALID, ONCE_VALID)


    def set_passwds(self, uids):
        """Set the password for one or more users"""
        # XXX - should be able to write to /var/local/mango

        PASSWDS = {}
        l = self._ldap

        for uid in uids:
            if uid not in self.UID_TO_CN:
                continue

            passwd = gen_passwd(length=12)
            hash = hash_ssha(passwd)
            PASSWDS[uid] = passwd

            dn = self.UID_TO_DN[uid]
            if uid in self.UID_TO_PW:
                old = {'userPassword': self.UID_TO_PW[uid]}
            else:
                old = {}
            ldif_entry = ldap.modlist.modifyModlist(old, {'userPassword': hash})
            l.modify_s(dn,ldif_entry)
        return PASSWDS


    def store_passwds(self, passwds):
        """Saves the password to files readable only by the intended UID.

        These passwords will be cleared asap."""
        if not passwds: return

        s = smtplib.SMTP()
        s.connect()

        for uid, passwd in passwds.iteritems():
            if uid not in self.UID_TO_CN: continue # XXX -- warn loudly

            mail = self.UID_TO_MAIL[uid]

            mime = MIMEText(self.EMAIL_TEMPLATE.safe_substitute(
                uid=uid,
                mail=mail,
                cn=self.UID_TO_CN[uid],

            ))
            mime['Subject'] = 'GNOME Mango account: %s' % uid
            mime['From'] = 'Mango <accounts@gnome.org>'
            mime['To'] = mail
            s.sendmail('accounts@gnome.org', [mail], mime.as_string())

    def update_ldap_ftpbasic(self, vcs_users, change=True, remove=False, verbose=False):
        """Updates LDAP module

        Used to synchronize information from VCS/l10n."""
        ldap_uids, ldap_modules, ldap_desc, ldap_dn, ldap_tarballs, ldap_ftpbasic = self.get_maintainer_data_ldap()
        l = self._ldap

        if not change: remove = False
        if not change: verbose=True

        dn = 'cn=%s,ou=groups,dc=gnome,dc=org' % escape_dn_chars('ftpbasic')

        vcs_ftpbasic  = set(vcs_users.keys())

        if ldap_ftpbasic != vcs_ftpbasic:
            ldif_entry = ldap.modlist.modifyModlist({'memberUid': list(ldap_ftpbasic)},
                    {'memberUid': list(vcs_ftpbasic)})
            if verbose:
                print "C:", dn, ldif_entry
            if change:
                l.modify_s(dn,ldif_entry)


    def update_ldap_modules(self, vcs_modules, vcs_descs, vcs_tarballs, change=True, remove=False, verbose=False):
        """Updates LDAP module

        Used to synchronize information from VCS/l10n."""
        ldap_uids, ldap_modules, ldap_desc, ldap_dn, ldap_tarballs, ftpbasic = self.get_maintainer_data_ldap()
        l = self._ldap

        if not change: remove = False
        if not change: verbose=True

        for modname in sorted(vcs_modules.keys()):
            dn = ldap_dn.get(modname, 'cn=%s,ou=modules,dc=gnome,dc=org' % escape_dn_chars(modname))
            maints = vcs_modules[modname]

            if len(modname) > 40:
                continue

            if modname not in ldap_modules: # add
                entry = {
                    'cn': modname,
                    'sn': modname,
                    'description': vcs_descs.get(modname, '%s module' % modname),
                    'maintainerUid': list(vcs_modules[modname]),
                }

                classes = ['gnomeModule', 'inetOrgPerson']
                # XXX - Fucking ugly hack
                if modname.startswith('l10n-') and modname in vcs_descs:
                    classes.append('localizationModule')
                    entry['localizationTeam'] = ' '
                else:
                    entry['tarballName'] = list(vcs_tarballs[modname])

                entry['objectClass'] = classes

                ldif_entry = ldap.modlist.addModlist(entry)
                if verbose:
                    print "A:", dn, ldif_entry
                if change:
                    l.add_s(dn, ldif_entry)
            elif ((modname in ldap_modules and vcs_modules[modname].symmetric_difference(ldap_modules[modname])) \
                  or (modname in vcs_tarballs and vcs_tarballs[modname].symmetric_difference(ldap_tarballs[modname]))):
                oldattrs = {
                    'maintainerUid': list(ldap_modules[modname]),
                }
                newattrs = {
                    'maintainerUid': list(vcs_modules[modname]),
                    'tarballName': list(vcs_tarballs[modname])
                }
                if not (modname.startswith('l10n-') and modname in vcs_descs):
                    oldattrs['tarballName'] = list(ldap_tarballs[modname])
                    newattrs['tarballName'] = list(vcs_tarballs[modname])


                ldif_entry = ldap.modlist.modifyModlist(oldattrs, newattrs)
                if verbose:
                    print "C:", dn, ldif_entry
                if change:
                    l.modify_s(dn,ldif_entry)

        if not remove: return

        rem_mods = set(ldap_modules.keys()).difference(vcs_modules.keys())
        if len(rem_mods):
            for modname in rem_mods:
                if modname not in ldap_dn:
                    continue
                if verbose:
                    print "D:", dn, ldap_dn[modname]
                
                l.delete_s(ldap_dn[modname])

        

def usage():
    print "Wrong usage"
    sys.exit(1)

def print_invalid(INVALID, filter_valid_uid=None, header=None):
    """Print problems in userid or email comparison to stdout"""
    printed_header = False
    if header is None: printed_header=True
    have_data=False

    table = texttable.Texttable(0)
    table.set_deco(0)
    table.header(('UID', 'DOAP email', 'LDAP email', 'DOAP name', 'Modules'))

    for uid in sorted(INVALID.keys()):
        if uid in ONCE_VALID: # XXX -- assumes specific scope
                continue

        for invalid_data in sorted(INVALID[uid].keys()):
            is_valid_uid, email, name = invalid_data

            if filter_valid_uid is not None and is_valid_uid != filter_valid_uid:
                continue

            if not printed_header:
                print header
                printed_header=True

            have_data=True
            table.add_row([uid, email, m.UID_TO_MAIL.get(uid, '???'), name, ", ".join(INVALID[uid][invalid_data])])

    if have_data:
        print table.draw().encode("utf-8")
    return have_data


if __name__ == '__main__':
    if len(sys.argv) < 2: usage()

    MANGO_CFG = {}

    cfg_files = ('/var/www/mango/config.xml', '/etc/mango/config.xml')

    import os.path
    for f in cfg_files:
        if os.path.exists(f):
            doc = et.parse(file(f, 'r'))
            root = doc.getroot()
            for el in root.getchildren():
                MANGO_CFG[el.tag] = el.text

            break

    LDAP_PASSWD = MANGO_CFG.get('ldap_bindpw', None)
    if 'ldap_url' in MANGO_CFG:
        Mango.LDAP_URL = MANGO_CFG['ldap_url']

    if not LDAP_PASSWD:
        print "Please provide the Manager LDAP password"
        LDAP_PASSWD = getpass('--> ')

    m = Mango(LDAP_PASSWD)

    cmd = sys.argv.pop(1)
    if cmd == 'sync' or cmd == 'show-diffs':
        change_stuff = cmd == 'sync'

        vcs_uids, vcs_modules, vcs_descs, vcs_tarballs, INVALID, ONCE_VALID = m.get_maintainer_data_vcs()

        m.update_ldap_modules(vcs_modules, vcs_descs, vcs_tarballs, change=change_stuff, remove=True, verbose=True)
        m.update_ldap_ftpbasic(vcs_uids, change=change_stuff, remove=True, verbose=True)

        uids_give_passwd = set(vcs_uids.keys()).difference(m.UID_TO_PW.keys())
        if uids_give_passwd:
            print "UIDs to give/reset passwords:"
            print ", ".join(uids_give_passwd)
            if change_stuff:
                passwds = m.set_passwds(uids_give_passwd)
                m.store_passwds(passwds)

        print_invalid(INVALID, False, "Invalid uids:")
        print_invalid(INVALID, True, "Mismatch between email addresses (DOAP vs LDAP):")

    elif cmd == 'test-reset':
        m.store_passwds({'ovitters': 'yeahright'})
    elif cmd == 'reset-passwd':
        uids = []
        for uid in sys.argv[1:]:
            if uid in m.UID_TO_PW:
                uids.append(uid)
        if uids:
            print 'Resetting passwords for: %s' % ', '.join(uids)
            passwds = m.set_passwds(uids)
            m.store_passwds(passwds)
    elif cmd == 'reset-my-passwd':
        import pwd

        protected = set(m.get_uids_from_group('sysadmin') + m.get_uids_from_group('accounts') + m.get_uids_from_group('mango'))
        uid = pwd.getpwuid(os.getuid())[0]
        if uid in protected or uid not in m.UID_TO_PW or uid not in m.VCS_UIDS:
            sys.exit(2)

        passwds = m.set_passwds([uid])
        print passwds[uid]
    elif cmd == 'new-passwd':
        uids = []
        for uid in sys.argv[1:]:
            if uid in m.UID_TO_MAIL and uid not in m.UID_TO_PW:
                uids.append(uid)
        if uids:
            print 'Setting new passwords for: %s' % ', '.join(uids)
            passwds = m.set_passwds(uids)
            m.store_passwds(passwds)
    elif cmd =='ldap-maints':
        ldap_uids, ldap_modules, ldap_desc, ldap_dn, ldap_tarballs, ftpbasic = m.get_maintainer_data_ldap()

        for uid in sorted(ldap_uids.keys()):
            print uid, ", ".join(ldap_uids[uid])
    else:
        usage()
    
