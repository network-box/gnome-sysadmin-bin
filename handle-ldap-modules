#!/usr/bin/python

# HINT:
#   ssh -L 1389:localhost:389 label
#   ssh -R 1389:localhost:1389 socket


import os
import sys
import glob
import ldap
import ldap.modlist
import string
from random import choice, randrange
from svn import fs, core, repos
import sha
from base64 import b64encode
import smtplib
from email.MIMEText import MIMEText
import libxml2

try: import readline
except: pass

def escape_dn_chars(s):
  """
  Escape all DN special characters found in s
  with a back-slash
  """
  if s:
    s = s.replace('\\','\\\\')
    s = s.replace(',' ,'\\,')
    s = s.replace('+' ,'\\+')
    s = s.replace('"' ,'\\"')
    s = s.replace('<' ,'\\<')
    s = s.replace('>' ,'\\>')
    s = s.replace(';' ,'\\;')
    s = s.replace('=' ,'\\=')
    if s[0]=='#':
      s = ''.join(('\\',s))
    if s[-1]==' ':
      s = ''.join((s[:-1],'\\ '))
  return s


def getpass(prompt = "Password: "):
    import termios
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    new = termios.tcgetattr(fd)
    new[3] = new[3] & ~termios.ECHO          # lflags
    try:
        termios.tcsetattr(fd, termios.TCSADRAIN, new)
        passwd = raw_input(prompt)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)
    return passwd


def is_executable(prog):
    if sys.platform == "win32":
        return True
    info = os.stat(prog)
    return (info.st_uid == os.getuid() and (info.st_mode & 0100) or
            info.st_gid == os.getgid() and (info.st_mode & 0010) or
            info.st_mode & 0001)


def find_program(prog):
    path = os.environ.get("PATH", "").split(os.pathsep)

    for directory in path:
        program = os.path.join(directory, prog)
        if os.path.exists(program) and is_executable(program):
            return program
    return ""


def gen_passwd(length=8, chars=string.letters + string.digits):
    return ''.join([choice(chars) for i in range(length)])


def hash_ssha(password):
    salt = ''.join([chr(randrange(0,255)) for i in range(4)])
    ctx = sha.new(password  + salt)
    hash = "{SSHA}" + b64encode(ctx.digest() + salt)
    return hash


CHUNK_SIZE = 16384
def svn_get_file(path, filename, rev=None):
    try:
        repos_ptr = repos.open(path)
    except core.SubversionException:
        return None
    fsob = repos.fs(repos_ptr)

    if rev is None:
        rev = fs.youngest_rev(fsob)

    root = fs.revision_root(fsob, rev)
    try:
        file = fs.file_contents(root, filename)
    except core.SubversionException:
        return None
    d = []
    while 1:
        data = core.svn_stream_read(file, CHUNK_SIZE)
        if not data:
            break
        d.append(data)
    return ''.join(d)


class Mango(object):

    #LDAP_URL = "ldap://ldap-back:389"
    LDAP_URL = "ldap://localhost:1389"
    LDAP_PASSWD = None
    _ldap = None

    EMAIL_TEMPLATE = string.Template("""Hello $cn,

There is a new way to get accounts setup asap. This using a system
called Mango. The new system will directly mail the maintainer(s) of the
responsible module / the language coordinator (you). With this email I'll try
to explain how it will work.

 ==> IF YOU AREN'T INTERESTED IN DETAILS, SEE END OF THE EMAIL FOR YOUR
 ==> PASSWORD

If you missed my blog post regarding Mango, please read/glance:
http://blogs.gnome.org/ovitters/2007/09/26/sneak-preview-of-mango/
(images are cropped, sorry)

Basically the process is as follows:
1. User requests account
2. User verifies email address
3. Mango mails maintainers / l10n coordinators
4. Maintainer/coordinator reject/approve account request
==> can need multiple maintainers if e.g. user requested e.g. Bugzilla
shell account and SVN for nautilus.. in practice, this won't happen
5a. Mango mails Accounts Team
5b. Mango mails progress information to the user
6. Accounts Team sets up user in LDAP
7. User gets welcome email

Note: steps 3-4 can be skipped as some requests will directly go to the
accounts team (e.g. @gnome.org alias)


What does not work:
* This is for new accounts. It will not work if the userid already
exists. This is planned for the future (so you can request an additional
group).
* You cannot change your Mango password. Sorry. See end of the email for
how to get your password.
* You cannot change your other details (SSH keys, email address). It is
planned, but can take a while before you see it.
* You cannot change who is maintainer of your modules. This is planned
for the future.
==> If you want to dicuss Mango, please use
gnome-infrastructure@gnome.org mailing list.


How to approve account requests:
* l10n coordinators: Make sure you have read
  http://live.gnome.org/TranslationProject/RequestingAnAccount
* You will get an email from Mango to your email address registered in
LDAP. This is (possibly) different from
http://foundation.gnome.org/membership/members.php!
* Go to https://mango.gnome.org/ and log in (see end of email for
password)
* You will get an overview of outstanding requests right after logging
in. See http://blogs.gnome.org/ovitters/files/2007/09/mango7.png. If
there aren't any outstanding requests, currently it only says something
like "Welcome $NAME" (and a log out button).
* Reject/approve the request(s) and click submit
Note: Because this goes to multiple persons, you might not see the
request even if you got an email from Mango. This means another person
was faster.
==> NOTE: The user will be informed. If you reject a person, please send
an explanation to the user. Ideally before you click submit, because
Mango will email the user right away.


In case of problems:
Please either email gnome-infrastructure@gnome.org, or file a bug:
http://bugzilla.gnome.org/enter_bug.cgi?product=sysadmin&component=mango
(sysadmin product, mango component)


YOUR MANGO PASSWORD
To see your mango password, do:
  ssh -l $uid svn.gnome.org mango

Your username is same as your SVN username.

Note: You can only run this command once. The next time it will have
forgotten what your password was.

Note2: For those who want to try out, this allows you to use the jabber
service (jabber.gnome.org, username is same as svn/mango/etc). Please
*enforce* SSL/TLS. Do NOT allow plain text auth! However, this is only
intended for foundation members (it'll work currently for everyone, but
that will not be forever). This was setup by Jeff, if it doesn't work,
it probably requires some other setting.""")

    def __init__(self, passwd):
        self.LDAP_PASSWD = passwd

        l = ldap.initialize(Mango.LDAP_URL)
        l.protocol_version = ldap.VERSION3
        l.simple_bind_s("cn=Manager,dc=gnome,dc=org", passwd)

        self._ldap = l
        self._init_ldap_accounts()


    def _init_ldap_accounts(self):
        self.UID_TO_DN = {}
        self.UID_TO_PW = {}
        self.UID_TO_MAIL = {}
        self.UID_TO_CN = {}
        self.UID_TO_NR = {}

        l = self._ldap
        results = l.search_s("dc=gnome,dc=org", ldap.SCOPE_SUBTREE, "objectClass=posixAccount", ('uid', 'cn', 'mail', 'userPassword', 'uidNumber'))
        for entry in results:
            id = entry[0]
            attr = entry[1]

            if 'mail' not in attr: # Make sure it isn't some internal userid
                continue

            uid = attr['uid'][0]
            cn = attr['cn'][0]

            self.UID_TO_DN[uid] = id
            if 'userPassword' in attr:
                self.UID_TO_PW[uid] = attr['userPassword'][0]
            self.UID_TO_CN[uid] = cn
            self.UID_TO_MAIL[uid] = attr['mail'][0].lower().strip()
            self.UID_TO_NR[uid] = int(attr['uidNumber'][0])


    def get_maintainer_data_ldap(self):
        """Get maintainer data from LDAP (cached)"""
        if hasattr(self, '_maint_ldap'):
            return self._maint_ldap

        UID_TO_MODULES = {}
        MODULE_TO_UIDS = {}
        MODULE_TO_DN = {}
        MODULE_TO_DESC = {}

        l = self._ldap
        results = l.search_s("dc=gnome,dc=org", ldap.SCOPE_SUBTREE, "(&(!(objectClass=localizationModule))(objectClass=gnomeModule))", ('cn', 'description','maintainerUid'))
        for entry in results:
            id = entry[0]
            attr = entry[1]

            modname = attr['cn'][0]
            uids = attr['maintainerUid']

            MODULE_TO_DN[modname] = id
            MODULE_TO_DESC[modname] = attr['description'][0]
            MODULE_TO_UIDS.setdefault(modname, set()).update(uids)
            for uid in uids:
                UID_TO_MODULES.setdefault(uid, set()).add(modname)

        self._maint_ldap = (UID_TO_MODULES, MODULE_TO_UIDS, MODULE_TO_DESC, MODULE_TO_DN)
        return self._maint_ldap


    def get_svn_modules(self):
        """Return a list of SVN modules (cached)"""
        if not hasattr(self, 'MODULES'):
            self.MODULES = [mod for mod in glob.glob('/svn/*') if os.path.exists(os.path.join(mod, 'hooks'))]

        return self.MODULES


    def get_maintainer_data_svn(self):
        """Try to find the maintainers of every GNOME SVN repository"""
        UID_TO_MODULES = {}
        MODULE_TO_UIDS = {}
        MODULE_TO_DESC = {}
        INVALID = {}
        ONCE_VALID = {}

        # Get translation teams from damned-lies XML info
        # This is hackish
        l10n = svn_get_file('/svn/damned-lies', '/trunk/translation-teams.xml.in')
        if l10n is None:
            sys.stderr.write("ERROR: Cannot find /trunk/translation-teams.xml.in in damned-lies!\n")
            sys.exit(1)

        bad_uids = []
        doc = libxml2.parseDoc(l10n)
        root = doc.getRootElement()
        teams = root.xpathEval("team[@id]")
        for team in teams:
            coordinators = [uid.prop('id') for uid in team.xpathEval('coordinator[@id]') if not uid.prop('id').startswith('x-')]
            bad = [uid for uid in coordinators if uid not in self.UID_TO_CN]
            if len(bad):
                coordinators = [uid for uid in coordinators if uid in self.UID_TO_CN]
                bad_uids.extend(bad)

            if not len(coordinators):
                continue

            team_id = team.prop('id')
            desc = None
            descs = team.xpathEval("_description")
            if len(descs):
                desc = descs[0].content
            if desc is None:
                descs = team.xpathEval("_language")
                desc = descs[0].content

            modname = 'l10n-%s' % team_id
            MODULE_TO_DESC[modname] = '%s (team %s)' % (desc, team_id)
            for uid in coordinators:
                UID_TO_MODULES.setdefault(uid, set()).add(modname)
                MODULE_TO_UIDS.setdefault(modname, set()).add(uid)

        doc.freeDoc()

        if len(bad_uids):
            print "Bad Uids in damned-lies:"
            print "\n".join(sorted(bad_uids))


        # Get module maintainer data from MAINTAINERS file in SVN
        for module in self.get_svn_modules():
            data = svn_get_file(module, '/trunk/MAINTAINERS')

            if data is None: continue

            modname = os.path.basename(module)
            data += "\n\n\n" # simplifies logic

            should_have_maint = False
            had_maint = False
            nr, name, email, uid = 0, None, None, None
            for l in data.splitlines():
                if l.startswith('#'): continue

                nr += 1

                if l.startswith("Userid:"): should_have_maint = True

                if l == "":
                    if name is not None and email is not None and uid is not None:
                        had_maint = True

                        is_valid_uid = uid in self.UID_TO_CN
                        possible_emails = ["%s@svn.gnome.org" % uid, "%s@gnome.org" % uid, "%s@cvs.gnome.org" % uid]
                        if is_valid_uid:
                            possible_emails.append(self.UID_TO_MAIL[uid])
                        spam_1 = [mail.replace('@', ' ').replace('.', ' ') for mail in possible_emails]
                        spam_2 = [mail.replace('@', ' at ').replace('.', ' dot ') for mail in possible_emails]
                        spam_3 = [mail.replace('@', ' ') for mail in possible_emails]
                        spam_4 = [mail.replace('@', ' at ') for mail in possible_emails]

                        possible_emails.extend(spam_1 + spam_2 + spam_3 + spam_4)
                        possible_emails.extend(['<%s>' % mail for mail in possible_emails])
 
                        is_valid_email = email in possible_emails
  
                        # XXX - not used/needed: self.MAINTAINERS.setdefault(modname, {})[uid] = [email, name, is_valid_uid, is_valid_email]
                        if is_valid_uid:
                            UID_TO_MODULES.setdefault(uid, set()).add(modname)
                            MODULE_TO_UIDS.setdefault(modname, set()).add(uid)
                        if not is_valid_uid or not is_valid_email:
                            if uid not in INVALID:
                                INVALID[uid] = [email, name, is_valid_uid, is_valid_email]
                            INVALID[uid].append(modname)
                        else:
                            ONCE_VALID[uid] = [email, name, is_valid_uid, is_valid_email]

                    nr, name, email, uid = 0, None, None, None
                    continue

                if nr > 3 or (nr > 1 and ": " not in l):
                    if email and uid:
                        print "ERROR: Possible forgotten empty line: %s" % modname
                    name, email, uid = None, None, None
                    continue

                if nr == 1:
                    name = l
                else:
                    field, value = l.split(": ", 1)
                    field = field.rstrip()
                    value = value.strip().lower()
                    if field == 'E-mail' or field == 'E-Mail' or field == 'Email' or field == 'EMail':
                        email = value
                    elif field == 'Userid':
                        uid = value
                    else:
                        print "ERROR: Strange field: %s (module: %s)" % (field, modname)


            if should_have_maint and not had_maint:
                print "ERROR: Expected at least one maintainer for module %s, but found none" % modname

        return (UID_TO_MODULES, MODULE_TO_UIDS, MODULE_TO_DESC, INVALID, ONCE_VALID)


    def set_passwds(self, uids):
        """Set the password for one or more users"""
        # XXX - should be able to write to /var/local/mango

        PASSWDS = {}
        l = self._ldap

        for uid in uids:
            if uid not in self.UID_TO_CN:
                continue

            passwd = gen_passwd(length=12)
            hash = hash_ssha(passwd)
            PASSWDS[uid] = passwd

            dn = self.UID_TO_DN[uid]
            if uid in self.UID_TO_PW:
                old = {'userPassword': self.UID_TO_PW[uid]}
            else:
                old = {}
            ldif = ldap.modlist.modifyModlist(old, {'userPassword': hash})
            l.modify_s(dn,ldif)
        return PASSWDS


    def store_passwds(self, passwds):
        """Saves the password to files readable only by the intended UID.

        These passwords will be cleared asap."""
        if not passwds: return

        s = smtplib.SMTP()
        s.connect()
        
        try:
            prevmask = os.umask(0177)
                
            for uid, passwd in passwds.iteritems():
                if uid not in self.UID_TO_CN: continue # XXX -- warn loudly
                
                mail = self.UID_TO_MAIL[uid]
                path = '/var/local/mango/%s' % uid
                
                f = file(path, 'w')
                print >>f, passwd
                f.close()
                os.chown(path, self.UID_TO_NR[uid], -1)

                mime = MIMEText(self.EMAIL_TEMPLATE.safe_substitute(
                    uid=uid,
                    mail=mail,
                    cn=self.UID_TO_CN[uid],

                ))
                mime['Subject'] = 'GNOME Mango account: %s' % uid
                mime['From'] = 'Mango <accounts@gnome.org>'
                mime['To'] = mail
                s.sendmail('accounts@gnome.org', [mail], mime.as_string())
        finally:
            os.umask(prevmask)
 

    def update_ldap_modules(self, svn_modules, svn_descs, change=True, remove=False):
        ldap_uids, ldap_modules, ldap_desc, ldap_dn = self.get_maintainer_data_ldap()
        l = self._ldap

        if not change: remove = False

        for modname in sorted(svn_modules.keys()):
            dn = ldap_dn.get(modname, 'cn=%s,ou=modules,dc=gnome,dc=org' % escape_dn_chars(modname))
            maints = svn_modules[modname]

            if modname not in ldap_modules: # add
                entry = {
                    'cn': modname,
                    'sn': modname,
                    'description': svn_descs.get(modname, '%s module' % modname),
                    'maintainerUid': list(svn_modules[modname])
                }
                
                classes = ['gnomeModule', 'inetOrgPerson']
                # XXX - Fucking ugly hack
                if modname.startswith('l10n-') and modname in svn_descs:
                    classes.append('localizationModule')
                    entry['localizationTeam'] = ' '

                entry['objectClass'] = classes
                

                ldif = ldap.modlist.addModlist(entry)
                if change:
                    l.add_s(dn, ldif)
                else:
                    print dn, ldif
            elif modname in ldap_modules and svn_modules[modname].symmetric_difference(ldap_modules[modname]):
                ldif = ldap.modlist.modifyModlist({'maintainerUid': list(ldap_modules[modname])},
                                             {'maintainerUid': list(svn_modules[modname])})
                if change:
                    l.modify_s(dn,ldif)
                else:
                    print dn, ldif

        if not remove: return

        rem_mods = set(ldap_modules.keys()).difference(svn_modules.keys())

        print "Modules to REALLY remove:"
        print rem_mods
        for modname in rem_mods:
            if modname not in ldap_dn:
                continue
            print ldap_dn[modname]
            
            l.delete_s(ldap_dn[modname]) # XXX - doesn't actually work

        

def usage():
    print "Wrong usage"
    sys.exit(1)


if __name__ == '__main__':
    if len(sys.argv) < 2: usage()

    print "Please provide the Manager LDAP password"
    LDAP_PASSWD = getpass('--> ')

    m = Mango(LDAP_PASSWD)

    cmd = sys.argv.pop(1)
    if cmd == 'sync' or cmd == 'show-diffs':
        change_stuff = cmd == 'sync'

        svn_data = m.get_maintainer_data_svn()
#        ldap_data = m.get_maintainer_data_ldap() # UID_TO_MODULES, MODULE_TO_UIDS, MODULE_TO_DESC

#        ul = set(ldap_data[1].keys())
#        us = set(svn_data[1].keys())
        desc_svn = svn_data[2]
        INVALID = svn_data[3]
        ONCE_VALID = svn_data[4]

#        new_mods = us.difference(ul)
#        removed_mods = ul.difference(us)
#        print "New modules:"
#        print sorted(new_mods)
#        print "Removed modules:"
#        print sorted(removed_mods)
#        for modname in us.intersection(ul):
#            mod_added = svn_data[1][modname].difference(ldap_data[1][modname])
#            mod_removed = ldap_data[1][modname].difference(svn_data[1][modname])
#            if len(mod_added) or len(mod_removed):
#                print "Module %s" % modname
#                print sorted(mod_added)
#                print sorted(mod_removed)

        for uid in sorted(INVALID.keys()):
                if uid in ONCE_VALID:
                        continue

                print "\t".join([uid, INVALID[uid][0], m.UID_TO_MAIL.get(uid, '???'), ", ".join(INVALID[uid][4:])])

        #m.update_ldap_modules(svn_data[1], remove=True)
        m.update_ldap_modules(svn_data[1], svn_data[2], change=change_stuff)

        uids_give_passwd = set(svn_data[0].keys()).difference(m.UID_TO_PW.keys())
        if uids_give_passwd:
            print "UIDs to give/reset passwords:"
            print ", ".join(uids_give_passwd)
            if change_stuff:
                passwds = m.set_passwds(uids_give_passwd)
                m.store_passwds(passwds)


    elif cmd == 'test-reset':
        m.store_passwds({'ovitters': 'yeahright'})
    elif cmd == 'reset-passwd':
        uids = []
        for uid in sys.argv[1:]:
            if uid in m.UID_TO_PW:
                uids.append(uid)
        if uids:
            print 'Resetting passwords for: %s' % ', '.join(uids)
            passwds = m.set_passwds(uids)
            m.store_passwds(passwds)
    elif cmd == 'new-passwd':
        uids = []
        for uid in sys.argv[1:]:
            if uid in m.UID_TO_MAIL and uid not in m.UID_TO_PW:
                uids.append(uid)
        if uids:
            print 'Setting new passwords for: %s' % ', '.join(uids)
            passwds = m.set_passwds(uids)
            m.store_passwds(passwds)
    else:
        usage()
    
