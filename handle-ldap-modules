#!/usr/bin/python

import os
import sys
import glob
import ldap
import ldap.modlist
import string
from random import choice, randrange
from svn import fs, core, repos
import sha
from base64 import b64encode
import smtplib
from email.MIMEText import MIMEText

try: import readline
except: pass

def escape_dn_chars(s):
  """
  Escape all DN special characters found in s
  with a back-slash
  """
  if s:
    s = s.replace('\\','\\\\')
    s = s.replace(',' ,'\\,')
    s = s.replace('+' ,'\\+')
    s = s.replace('"' ,'\\"')
    s = s.replace('<' ,'\\<')
    s = s.replace('>' ,'\\>')
    s = s.replace(';' ,'\\;')
    s = s.replace('=' ,'\\=')
    if s[0]=='#':
      s = ''.join(('\\',s))
    if s[-1]==' ':
      s = ''.join((s[:-1],'\\ '))
  return s


def getpass(prompt = "Password: "):
    import termios
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    new = termios.tcgetattr(fd)
    new[3] = new[3] & ~termios.ECHO          # lflags
    try:
        termios.tcsetattr(fd, termios.TCSADRAIN, new)
        passwd = raw_input(prompt)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)
    return passwd


def is_executable(prog):
    if sys.platform == "win32":
        return True
    info = os.stat(prog)
    return (info.st_uid == os.getuid() and (info.st_mode & 0100) or
            info.st_gid == os.getgid() and (info.st_mode & 0010) or
            info.st_mode & 0001)


def find_program(prog):
    path = os.environ.get("PATH", "").split(os.pathsep)

    for directory in path:
        program = os.path.join(directory, prog)
        if os.path.exists(program) and is_executable(program):
            return program
    return ""


def gen_passwd(length=8, chars=string.letters + string.digits):
    return ''.join([choice(chars) for i in range(length)])


def hash_ssha(password):
    salt = ''.join([chr(randrange(0,255)) for i in range(4)])
    ctx = sha.new(password  + salt)
    hash = "{SSHA}" + b64encode(ctx.digest() + salt)
    return hash


CHUNK_SIZE = 16384
def svn_get_file(path, filename, rev=None):
    try:
        repos_ptr = repos.open(path)
    except core.SubversionException:
        return None
    fsob = repos.fs(repos_ptr)

    if rev is None:
        rev = fs.youngest_rev(fsob)

    root = fs.revision_root(fsob, rev)
    try:
        file = fs.file_contents(root, filename)
    except core.SubversionException:
        return None
    d = []
    while 1:
        data = core.svn_stream_read(file, CHUNK_SIZE)
        if not data:
            break
        d.append(data)
    return ''.join(d)


class Mango(object):

    #LDAP_URL = "ldap://ldap-back:389"
    LDAP_URL = "ldap://localhost:1389"
    LDAP_PASSWD = None
    _ldap = None

    EMAIL_TEMPLATE = string.Template("""Hello $cn,

There is a new way to get accounts setup asap. This using a system
called Mango. The new system will directly mail the maintainer(s) of the
responsible module (you). With this email I'll try to explain how it
will work.

 ==> IF YOU AREN'T INTERESTED IN DETAILS, SEE END OF THE EMAIL FOR YOUR
 ==> PASSWORD

If you missed my blog post regarding Mango, please read/glance:
http://blogs.gnome.org/ovitters/2007/09/26/sneak-preview-of-mango/
(images are cropped, sorry)

Basically the process is as follows:
1. User requests account
2. User verifies email address
3. Mango mails maintainers
4. Maintainers reject/approve account request
==> can need multiple maintainers if e.g. user requested e.g. Bugzilla
shell account and SVN for nautilus.. in practice, this won't happen
5a. Mango mails Accounts Team
5b. Mango mails user giving advice on the progress
6. Accounts Team sets up user in LDAP
7. User gets welcome email

Note: steps 3-4 can be skipped as some requests will directly go to the
accounts team (e.g. @gnome.org alias)


What does not work:
* This is for new accounts. It will not work if the userid already
exists. This is planned for the future (so you can request an additional
group).
* You cannot change your Mango password. Sorry. See end of the email for
how to get your password.
* You cannot change your other details (SSH keys, email address). It is
planned, but can take a while before you see it.
* You cannot change who is maintainer of your modules. This is planned
for the future.
==> If you want to dicuss Mango, please use
gnome-infrastructure@gnome.org mailing list.


How to approve account requests:
* You will get an email from Mango to your email address registered in
LDAP. This is (possibly) different from
http://foundation.gnome.org/membership/members.php!
* Go to https://mango.gnome.org/ and log in (see end of email for
password)
* You will get an overview of outstanding requests right after logging
in. See http://blogs.gnome.org/ovitters/files/2007/09/mango7.png. If
there aren't any outstanding requests, currently it only says something
like "Welcome $NAME" (and a log out button).
* Reject/approve the request(s) and click submit
Note: Because this goes to multiple persons, you might not see the
request even if you got an email from Mango. This means another person
was faster.
==> NOTE: The user will be informed. If you reject a person, please send
an explanation to the user. Ideally before you click submit, because
Mango will email the user right away.


In case of problems:
Please either email gnome-infrastructure@gnome.org, or file a bug:
http://bugzilla.gnome.org/enter_bug.cgi?product=sysadmin&component=mango
(sysadmin product, mango component)


YOUR MANGO PASSWORD
To see your mango password, do:
  ssh -l $uid svn.gnome.org mango

Your username is same as your SVN username.

Note: You can only run this command once. The next time it will have
forgotten what your password was.

Note2: For those who want to try out, this allows you to use the jabber
service (jabber.gnome.org, username is same as svn/mango/etc). Please
*enforce* SSL/TLS. Do NOT allow plain text auth! However, this is only
intended for foundation members (it'll work currently for everyone, but
that will not be forever). This was setup by Jeff, if it doesn't work,
it probably requires some other setting.""")

    def __init__(self, passwd):
        self.LDAP_PASSWD = passwd

        l = ldap.initialize(Mango.LDAP_URL)
        l.protocol_version = ldap.VERSION3
        l.simple_bind_s("cn=Manager,dc=gnome,dc=org", LDAP_PASSWD)

        self._ldap = l
        self._init_ldap_accounts()


    def _init_ldap_accounts(self):
        self.UID_TO_DN = {}
        self.UID_TO_PW = {}
        self.UID_TO_MAIL = {}
        self.UID_TO_CN = {}
        self.UID_TO_NR = {}

        l = self._ldap
        results = l.search_s("dc=gnome,dc=org", ldap.SCOPE_SUBTREE, "objectClass=posixAccount", ('uid', 'cn', 'mail', 'userPassword', 'uidNumber'))
        for entry in results:
            id = entry[0]
            attr = entry[1]

            if 'mail' not in attr: # Make sure it isn't some internal userid
                continue

            uid = attr['uid'][0]
            cn = attr['cn'][0]

            self.UID_TO_DN[uid] = id
            if 'userPassword' in attr:
                self.UID_TO_PW[uid] = attr['userPassword'][0]
            self.UID_TO_CN[uid] = cn
            self.UID_TO_MAIL[uid] = attr['mail'][0].lower().strip()
            self.UID_TO_NR[uid] = int(attr['uidNumber'][0])


    def get_maintainer_data_ldap(self):
        """Get maintainer data from LDAP (cached)"""
        if hasattr(self, '_maint_ldap'):
            return self._maint_ldap

        UID_TO_MODULES = {}
        MODULE_TO_UIDS = {}
        MODULE_TO_DN = {}

        l = self._ldap
        results = l.search_s("dc=gnome,dc=org", ldap.SCOPE_SUBTREE, "(&(!(objectClass=localizationModule))(objectClass=gnomeModule))", ('cn', 'description','maintainerUid'))
        for entry in results:
            id = entry[0]
            attr = entry[1]
            
            modname = attr['cn'][0]
            uids = attr['maintainerUid']

            MODULE_TO_DN[modname] = id
            MODULE_TO_UIDS.setdefault(modname, set()).update(uids)
            for uid in uids:
                UID_TO_MODULES.setdefault(uid, set()).add(modname)
        
        self._maint_ldap = (UID_TO_MODULES, MODULE_TO_UIDS, MODULE_TO_DN)
        return self._maint_ldap


    def get_svn_modules(self):
        """Return a list of SVN modules (cached)"""
        if not hasattr(self, 'MODULES'):
            self.MODULES = [mod for mod in glob.glob('/svn/*') if os.path.exists(os.path.join(mod, 'hooks'))]

        return self.MODULES


    def get_maintainer_data_svn(self):
        """Try to find the maintainers of every GNOME SVN repository"""
        UID_TO_MODULES = {}
        MODULE_TO_UIDS = {}
        INVALID = {}
        ONCE_VALID = {}


        for module in self.get_svn_modules():
            data = svn_get_file(module, '/trunk/MAINTAINERS')

            if data is None: continue

            modname = os.path.basename(module)
            data += "\n\n\n" # simplifies logic

            should_have_maint = False
            had_maint = False
            nr, name, email, uid = 0, None, None, None
            for l in data.splitlines():
                if l.startswith('#'): continue

                nr += 1
                
                if l.startswith("Userid:"): should_have_maint = True

                if l == "":
                    if name is not None and email is not None and uid is not None:
                        had_maint = True

                        is_valid_uid = uid in self.UID_TO_CN
                        possible_emails = ["%s@svn.gnome.org" % uid, "%s@gnome.org" % uid, "%s@cvs.gnome.org" % uid]
                        if is_valid_uid:
                            possible_emails.append(self.UID_TO_MAIL[uid])
                        spam_1 = [mail.replace('@', ' ').replace('.', ' ') for mail in possible_emails]
                        spam_2 = [mail.replace('@', ' at ').replace('.', ' dot ') for mail in possible_emails]
                        spam_3 = [mail.replace('@', ' ') for mail in possible_emails]
                        spam_4 = [mail.replace('@', ' at ') for mail in possible_emails]

                        possible_emails.extend(spam_1 + spam_2 + spam_3 + spam_4)
                        possible_emails.extend(['<%s>' % mail for mail in possible_emails])
 
                        is_valid_email = email in possible_emails
  
                        # XXX - not used/needed: self.MAINTAINERS.setdefault(modname, {})[uid] = [email, name, is_valid_uid, is_valid_email]
                        if is_valid_uid:
                            UID_TO_MODULES.setdefault(uid, set()).add(modname)
                            MODULE_TO_UIDS.setdefault(modname, set()).add(uid)
                        if not is_valid_uid or not is_valid_email:
                            if uid not in INVALID:
                                INVALID[uid] = [email, name, is_valid_uid, is_valid_email]
                            INVALID[uid].append(modname)
                        else:
                            ONCE_VALID[uid] = [email, name, is_valid_uid, is_valid_email]

                    nr, name, email, uid = 0, None, None, None
                    continue

                if nr > 3 or (nr > 1 and ": " not in l):
                    if email and uid:
                        print "ERROR: Possible forgotten empty line: %s" % modname
                    name, email, uid = None, None, None
                    continue

                if nr == 1:
                    name = l
                else:
                    field, value = l.split(": ", 1)
                    field = field.rstrip()
                    value = value.strip().lower()
                    if field == 'E-mail' or field == 'E-Mail' or field == 'Email' or field == 'EMail':
                        email = value
                    elif field == 'Userid':
                        uid = value
                    else:
                        print "ERROR: Strange field: %s (module: %s)" % (field, modname)


            if should_have_maint and not had_maint:
                print "ERROR: Expected at least one maintainer for module %s, but found none" % modname
        
        return (UID_TO_MODULES, MODULE_TO_UIDS, INVALID, ONCE_VALID)


    def set_passwds(self, uids):
        """Set the password for one or more users"""
        # XXX - should be able to write to /var/local/mango

        PASSWDS = {}
        l = self._ldap

        for uid in uids:
            if uid not in self.UID_TO_CN:
                continue
                
            passwd = gen_passwd(length=12)
            hash = hash_ssha(passwd)
            PASSWDS[uid] = passwd

            dn = self.UID_TO_DN[uid]
            if uid in self.UID_TO_PW:
                old = {'userPassword': self.UID_TO_PW[uid]}
            else:
                old = {}
            ldif = ldap.modlist.modifyModlist(old, {'userPassword': hash})
            l.modify_s(dn,ldif)
        return PASSWDS

#alo, jsh, treitter, charles, jjsanchez, bratsche, aleksey, johnp, johncarr, gauteh, dbera, markoa, luca, thomasvm, cyenyxe, erichs, rdraica, psanxiao, mvdpot, carlosd, kmaute, hasselmm, telemaco, rancell, chrisime, fredgo, kvansant, davidz, aruiz, masneyb, jtai, rbradford, oserb, bjornl, rodo, zcerza, lucilanga, samh, hub, jpu, jstowers, calvinrg, bradya, ramonnb, bgarret, hiikezoe, ccollier, dov

    def store_passwds(self, passwds):
        """Saves the password to files readable only by the intended UID.

        These passwords will be cleared asap."""
        if not passwds: return

        s = smtplib.SMTP()
        s.connect()
        
        try:
            prevmask = os.umask(0377)
                
            for uid, passwd in passwds.iteritems():
                if uid not in self.UID_TO_CN: continue # XXX -- warn loudly
                
                mail = self.UID_TO_MAIL[uid]
                path = '/var/local/mango/%s' % uid
                
                f = file(path, 'w')
                print >>f, passwd
                f.close()
                os.chown(path, self.UID_TO_NR[uid], -1)

                mime = MIMEText(self.EMAIL_TEMPLATE.safe_substitute(
                    uid=uid,
                    mail=mail,
                    cn=self.UID_TO_CN[uid],

                ))
                mime['Subject'] = 'GNOME Mango account: %s' % uid
                mime['From'] = 'Mango <accounts@gnome.org>'
                mime['To'] = mail
                s.sendmail('accounts@gnome.org', [mail], mime.as_string())
        finally:
            os.umask(prevmask)
 

    def update_ldap_modules(self, modules, remove=False):
        ldap_uids, ldap_modules, ldap_dn  = self.get_maintainer_data_ldap()
        l = self._ldap

        for modname in sorted(modules.keys()):
            dn = ldap_dn.get(modname, 'cn=%s,ou=modules,dc=gnome,dc=org' % escape_dn_chars(modname))
            maints = modules[modname]

            if modname not in ldap_modules: # add
                ldif = ldap.modlist.addModlist(
                    {'objectClass': ['gnomeModule', 'inetOrgPerson'],
                     'cn': modname,
                     'sn': modname,
                     'description': '%s module' % modname,
                     'maintainerUid': list(modules[modname])}
                )
                l.add_s(dn, ldif)
            elif modname in ldap_modules and modules[modname].symmetric_difference(ldap_modules[modname]):
                ldif = ldap.modlist.modifyModlist({'maintainerUid': list(ldap_modules[modname])},
                                             {'maintainerUid': list(modules[modname])})
                l.modify_s(dn,ldif)
       
        if not remove: return

        rem_mods = set(ldap_modules.keys()).difference(modules.keys())

        print "Modules to REALLY remove:"
        print rem_mods
        for modname in rem_mods:
            if modname not in ldap_dn:
                continue
            print ldap_dn[modname]
            
            l.delete_s(ldap_dn[modname])

        

def usage():
    print "Wrong usage"
    sys.exit(1)


if __name__ == '__main__':
    if len(sys.argv) < 2: usage()

    print "Please provide the Manager LDAP password"
    LDAP_PASSWD = getpass('--> ')

    m = Mango(LDAP_PASSWD)

    cmd = sys.argv.pop(1)
    if cmd == 'sync':
        ldap_data = m.get_maintainer_data_ldap() # UID_TO_MODULES, MODULE_TO_UIDS
        svn_data = m.get_maintainer_data_svn()

        ul = set(ldap_data[1].keys())
        us = set(svn_data[1].keys())
        INVALID = svn_data[2]
        ONCE_VALID = svn_data[3]

        new_mods = us.difference(ul)
        removed_mods = ul.difference(us)
#        print "New modules:"
#        print sorted(new_mods)
#        print "Removed modules:"
#        print sorted(removed_mods)
#        for modname in us.intersection(ul):
#            mod_added = svn_data[1][modname].difference(ldap_data[1][modname])
#            mod_removed = ldap_data[1][modname].difference(svn_data[1][modname])
#            if len(mod_added) or len(mod_removed):
#                print "Module %s" % modname
#                print sorted(mod_added)
#                print sorted(mod_removed)

        for uid in sorted(INVALID.keys()):
                if uid in ONCE_VALID:
                        continue

                print "\t".join([uid, INVALID[uid][0], m.UID_TO_MAIL.get(uid, '???'), ", ".join(INVALID[uid][4:])])

        #m.update_ldap_modules(svn_data[1], remove=True)
        m.update_ldap_modules(svn_data[1])

        uids_give_passwd = set(svn_data[0].keys()).difference(m.UID_TO_PW.keys())
        if uids_give_passwd:
            print "UIDs to give/reset passwords:"
            print ", ".join(uids_give_passwd)
            passwds = m.set_passwds(uids_give_passwd)
            m.store_passwds(passwds)


    elif cmd == 'test-reset':
        m.store_passwds({'ovitters': 'yeahright'})
    else:
        usage()
    
