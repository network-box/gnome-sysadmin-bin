#!/usr/bin/env python

# This script should be run with the output written to /git/cgit.repositories, which
# is included from /etc/cgitrc

from optparse import OptionParser
import os
import re
import sys

# Namespaces for DOAP files
DOAP = "http://usefulinc.com/ns/doap#"
GNOME = "http://api.gnome.org/doap-extensions#"

# This is what GIT writes by default, we replace it with something better
NO_DESCRIPTION = 'Unnamed repository; edit this file to name it for gitweb.'

sectionlist = ('Administration Tools', 'Bindings', 'Desktop', 'Development Tools',
             'Infrastructure', 'Platform', 'Productivity Tools', 'Other', 'Deprecated', 'Archived')
sectionmap = {
    'admin': 'Administration Tools',
    'bindings': 'Bindings',
    'deprecated': 'Deprecated',
    'desktop': 'Desktop',
    'development': 'Development Tools',
    'infrastructure': 'Infrastructure',
    'platform': 'Platform',
    'productivity': 'Productivity Tools'
    }
sections = {}
for section in sectionlist:
    sections[section] = []

class Repo:
    def __init__(self, repopath):
        self.path = repopath
        self.pending = os.path.isfile(os.path.join(repopath, 'pending'))

        shortname = re.sub('/git/', '', repopath)
        shortname = re.sub('/srv/', '', shortname)
        shortname = re.sub('\.git$', '', shortname)
        shortname = re.sub('/home/', '~', shortname)
        self.shortname = shortname

        pending = ''
        if self.pending:
            pending = '[PENDING] '

        desc_file = os.path.join(repopath, 'description')
        desc = ''
        if os.path.isfile(desc_file):
            desc = open(desc_file).readline().strip()
            if desc == '' or desc == NO_DESCRIPTION:
                desc = "Please create %s.doap (see http://live.gnome.org/Git/FAQ)" % shortname
        self.desc = pending + desc

        section_file = os.path.join(repopath, 'gnome_group')
        section = None
        if os.path.isfile(section_file):
            section = open(section_file).readline().strip()
        self.section = sectionmap.get(section, 'Other')

# Sort alphabetically by name
def sort_repos(a, b):
    return cmp(a.shortname, b.shortname)

# Call a function on each repository
def iter_repos (paths, repo_func, include_pending=True):
    for p in paths:
        if type(p) is tuple:
            path, force_section = p
        else:
            path, force_section = p, None
        if not os.path.isdir(path):
            continue
        for repo in os.listdir(path):
            repopath = os.path.join (path, repo)
            # We check for ./refs to avoid non-git repository subdirs
            if not os.path.isdir(os.path.join(repopath, 'refs')):
                continue

            repo = Repo(repopath)
            if not include_pending and repo.pending:
                continue
            if force_section:
                repo.section = force_section
            sections[repo.section].append(repo)

    for section in sectionlist:
        for repo in sorted(sections[section], sort_repos):
            repo_func(repo)

def output_cgit(repo):
    print 'repo.section=%s' % repo.section
    print 'repo.url=%s' % repo.shortname
    print 'repo.name=%s' % repo.shortname
    print 'repo.desc=%s' % repo.desc
    print 'repo.path=%s' % repo.path
    print

def output_flat(repo):
    print repo.shortname

parser = OptionParser()
parser.add_option('', "--output", action='store', choices=['cgit', 'flat', 'doap'],
                  help="Type of output to produce")
options, args = parser.parse_args()

if len(args) == 0:
    paths = ['/git', '/git/preview']
else:
    paths = args

if options.output == 'cgit':
    paths.append(('/git/archive', 'Archived'))
    iter_repos (paths, output_cgit)
elif options.output == 'flat':
    iter_repos (paths, output_flat, include_pending=False)
elif options.output == 'doap':
    import semi_rdf

    nodes = []
    def add_file(repo):
        doapfile = os.path.join(repo.path, "gnome_doap")
        if os.path.isfile(doapfile):
            f = open(doapfile)
            file_nodes = semi_rdf.read_rdf(f)
            f.close()

            repository_node = semi_rdf.Node((DOAP, "GitRepository"))
            repository_node.add_property((DOAP, "location"),
                                         None,
                                         semi_rdf.UrlResource("git://git.gnome.org/%s" % repo.shortname))
            repository_node.add_property((DOAP, "browse"),
                                       None,
                                       semi_rdf.UrlResource("http://git.gnome.org/cgit/%s" % repo.shortname))
            old_repository_node = None

            for node in file_nodes:
                if node.name != (DOAP, "Project"):
                    continue

                old_repository_node = node.find_property((DOAP, "repository"))
                node.remove_property((DOAP, "repository"))
                node.add_property((DOAP, "repository"),
                                  None,
                                  repository_node)

            # Don't want the old repository emitted as a toplevel node
            if old_repository_node:
                file_nodes.remove(old_repository_node)

            nodes.extend(file_nodes)
            nodes.append(repository_node)

    iter_repos(paths, add_file, include_pending=False)
    semi_rdf.dump_rdf(nodes, sys.stdout)
