#!/usr/bin/python

import sys
import os
import os.path
import grp
import pwd
import ldap
import ldap.filter
import re
import tempfile
import tarfile
import pprint
import difflib
from optparse import OptionParser


GROUP='ftpadmin'
LDAP_BASE='ou=modules,dc=gnome,dc=org'
re_file = re.compile(r'^(?P<module>.*?)[_-](?:(?P<oldversion>([0-9]+[\.])*[0-9]+)-)?(?P<version>([0-9]+[\.\-])*[0-9]+)\.(?P<format>(?:tar\.|diff\.)?[a-z][a-z0-9]*)$')
re_version = re.compile(r'^([0-9]+\.[0-9]+).*')

usage = "usage: %prog [options] TARBALL"
description = """Install new tarball to GNOME FTP master and mirrors.

Example: install-module -u metacity-2.4.1.tar.gz

Report bugs to gnome-sysadmin@gnome.org"""

parser = OptionParser(usage=usage, description=description)
parser.add_option("-f", "--force", action="store_true", dest="clobber",
                          help="Overwrite the original tarball")
parser.add_option("-u", "--unattended", action="store_true",
        help="do not prompt for confirmation.\n\nNOTE: An unattended install " +
        "will not provide any extra information to help you avoid an invalid " +
        "(and potentially messy) installation. It is recommended that you do not " +
        "use this unless you are *very* sure.")

parser.set_defaults(clobber=False, unattended=False)

def version_cmp(a, b):
    a_nums = a.replace('-', '.0.').split('.')
    b_nums = b.replace('-', '.0.').split('.')
    num_fields = min(len(a_nums), len(b_nums))
    for i in range(0,num_fields):
        if   int(a_nums[i]) < int(b_nums[i]):
            return -1
        elif int(a_nums[i]) > int(b_nums[i]):
            return 1
    return cmp(len(a_nums), len(b_nums))

def get_latest_version(versions, max_version=None):
    """Gets the latest version number

    if max_version is specified, gets the latest version number before
    max_version"""
    latest = None
    for version in versions:
        if ( latest is None or version_cmp(version, latest) > 0 ) \
           and ( max_version is None or version_cmp(version, max_version) < 0 ):
            latest = version
    return latest

# COPY/PASTE from releng/convert-to-tarballs.py
def _bigger_version(a, b):
    a_nums = a.split('.')
    b_nums = b.split('.')
    num_fields = min(len(a_nums), len(b_nums))
    for i in range(0,num_fields):
        if   int(a_nums[i]) > int(b_nums[i]):
            return a
        elif int(a_nums[i]) < int(b_nums[i]):
            return b
    if len(a_nums) > len(b_nums):
        return a
    else:
        return b

# This is nearly the same as _bigger_version, except that
#   - It returns a boolean value
#   - If max_version is None, it just returns False
#   - It treats 2.13 as == 2.13.0 instead of 2.13 as < 2.13.0
# The second property is particularly important with directory hierarchies
def _version_greater_or_equal_to_max(a, max_version):
    if not max_version:
        return False
    a_nums = a.split('.')
    b_nums = max_version.split('.')
    num_fields = min(len(a_nums), len(b_nums))
    for i in range(0,num_fields):
        if   int(a_nums[i]) > int(b_nums[i]):
            return True
        elif int(a_nums[i]) < int(b_nums[i]):
            return False
    return True

def get_latest_version_orig(versions, max_version):
    biggest = versions[0]
    for version in versions[1:]:
        if (version == _bigger_version(biggest, version) and \
            not _version_greater_or_equal_to_max(version, max_version)):
            biggest = version
    return biggest
# END COPY/PASTE


class TarInfo(object):

    def __init__(self, path, files=set()):
        self.path = path
        self.file = {}

        self.dirname, self.basename = os.path.split(path)

        tarinfo_files = files.copy()

        r = re_file.match(self.basename)
        if r:
            fileinfo = r.groupdict()

            self.module = fileinfo['module']
            self.version = fileinfo['version']
            self.format = fileinfo['format']
            self.majmin = re_version.sub(r'\1', fileinfo['version'])

            tarinfo_files.add('%s-%s/ChangeLog' % (self.module, self.version))
            tarinfo_files.add('%s-%s/NEWS' % (self.module, self.version))
        else:
            self.module = None
            self.version = None
            self.format = None
            self.majmin = None

        self.files = tarinfo_files

    def check(self):
        """Check tarball consistency"""
        files = self.files

        t = tarfile.open(self.path, 'r', errors=2)
        size_files = 0
        file_count = 0
        for info in t:
            if info.name in files:
                self.file[os.path.basename(info.name)] = t.extractfile(info).readlines()

            size_files += info.size
            file_count += 1


        # Now determine the current position in the tar file
        tar_end_of_data_pos = t.fileobj.tell()
        # as well as the last position in the tar file
        #t.fileobj.seek(0, os.SEEK_END)
        t.fileobj.read()
        tar_end_of_file_pos = t.fileobj.tell()
        t.close()

        self.size_files = size_files
        self.file_count = file_count
        self.tar_end_of_data_pos = tar_end_of_data_pos
        self.tar_end_of_file_pos = tar_end_of_file_pos


class ModuleInfo(object):
    FTPROOT='/ftp/pub/GNOME'

    def __init__(self, modulename):
        self.module = modulename

        # Determine maintainers
        self.maintainers = []
        if self.module:
            data = get_module_info(self.module)
            if len(data):
                self.maintainers = data[0][1]['maintainerUid']

            self.jsonfile = os.path.join(self.FTPROOT, 'sources', self.module, '%s.json' % self.module)

        self.read_json()

    def refresh(self):
        if self.module is None: return False

        self.read_json(force_refresh=True)

    def read_json(self, force_refresh=False):
        if self.module is None:
            self.info = {}
            self.majmin = {}
            self.versions = []

            return False

        info = {}
        majmins = {}

        if force_refresh or not os.path.exists(self.jsonfile):
            top = os.path.join(self.FTPROOT, 'sources', self.module)
            for root, dirs, files in os.walk(top, topdown=False):
                for filename in files:
                    r = re_file.match(filename)
                    if r:
                        fileinfo = r.groupdict()
                        module = fileinfo['module']
                        version = fileinfo['version']
                        format = fileinfo['format']

                        if module != self.module:
                            continue

                        info.setdefault(version, {})[format] = os.path.join(root, filename)
        else:
            # XXX - actually load the json file..
            pass

        # XXX - maybe remove versions where there are no .tar.*


        # Group versions by major and minor number
        for version in info:
            majmin = re_version.sub(r'\1', version)
            if majmin not in majmins:
                majmins[majmin] = set()

            majmins[majmin].add(version)

        self.info = info
        self.majmin = majmins
        self.versions = sorted(info, version_cmp)


    def write_json(self): # XXX - should write json
        if self.module is None: return False

        info = self.info
        #self.info = info


class InstallModule(object):
    FTPROOT='/ftp/pub/GNOME'
    URLROOT='http://download.gnome.org'

    FORMATS = ('tar.gz', 'tar.bz2')

    def __init__(self, file):
        self.file = file

        self.uid = os.getuid()
        self.pw = pwd.getpwuid(self.uid)

        self.dirname, self.basename = os.path.split(file)
        self.fileinfo = TarInfo(file)

        if self.fileinfo.module is not None:
            self.module = self.fileinfo.module
            self.majmin = self.fileinfo.majmin
            self.version = self.fileinfo.version
            self.format = self.fileinfo.format

            self.destination = '%s/sources/%s/%s' % (self.FTPROOT, self.fileinfo.module, self.majmin)

        self.moduleinfo = ModuleInfo(self.fileinfo.module)
        self.moduleinfo.write_json()
        self.prevversion = get_latest_version(self.moduleinfo.versions, self.version)



    def confirm_install(self):

        print """      Module: %s
     Version: %s   (previous version: %s)
     Maj.Min: %s
 Destination: %s/""" % (self.module, self.version, self.prevversion or 'N/A', self.majmin, self.destination)

        # Check if the module directory already exists. If not, the module name might contain a typo
        if not os.path.isdir('%s/sources/%s' % (self.FTPROOT, self.module)):
            print """
WARNING: %s is not present in the archive!
         Are you sure that it is new and/or the correct module name?""" % self.module

        print """
Install %s? [Y/n]""" % self.module,
        response = raw_input()

        if response != '' and response[0] != 'y' and response[0] != 'Y':
            print """Module installation cancelled. Please report any problems with this
script to gnome-sysadmin@gnome.org. Thanks."""

            return False

        # install the module
        return True

    def validate(self):
        if self.module is None:
            print 'ERROR: Unrecognized module/version/file format. Make sure to follow a sane naming scheme (MAJOR.MINOR.MICRO)'
            return False

        # Don't allow an existing tarball to be overwritten
        if os.path.exists(os.path.join(self.destination, self.basename)):
            print """ERROR: %s already exists in the archive!""" % self.basename
            # XXX - continuing anyway
            #return False

        # XXX - verify if tarball is being installed by a maintainer

        # CHECK FOR CONSISTENCY

        errors = self.fileinfo.check()

        tar = tarfile.open(self.file)

        # CHECK 1: Make sure tarball contains a directory called $MODULE-$VERSION
        dir = None
        try:
            dir = tar.getmember('%s-%s' % (self.module, self.version))
        except KeyError:
            pass
        if dir and not dir.isdir():
            dir = None
        if dir is None:
            print 'ERROR: Cannot find expected directory within tarball, aborting!'
            return False

        # Valid file
        return True

    def install(self, unattended=False):
        # Validate the file
        if not self.validate():
            return False


        # Ask user if tarball should be installed
        if not unattended:
            if not self.confirm_install():
                return False


        for k, v in self.__dict__.iteritems():
            print k, v

        if self.prevversion:
            prev_fileinfo = TarInfo(self.moduleinfo.info[self.prevversion]['tar.bz2'])
            prev_errors = prev_fileinfo.check()

            for fn in self.fileinfo.file:
                if fn in prev_fileinfo.file:
                    context = 0
                    a = prev_fileinfo.file[fn]
                    b = self.fileinfo.file[fn]
                    for group in difflib.SequenceMatcher(None,a,b).get_grouped_opcodes(context):
                        i1, i2, j1, j2 = group[0][1], group[-1][2], group[0][3], group[-1][4]
                        for tag, i1, i2, j1, j2 in group:
                            if tag == 'replace' or tag == 'insert':
                                for line in b[j1:j2]:
                                    print line,

                else:
                    print "No %s in %s!" % (fn, self.moduleinfo.info[self.prevversion]['tar.bz2'])


#        if not os.path.isdir(self.destination):
#            os.makedirs(self.destination, 042775) # drwxrwsr-x
        # XXX - install the tarball
        # XXX - change ownership of the tarball

l = None
def get_module_info(module):
    global l # evil

    if l is None:
        l = ldap.open('ldap-back')
        l.protocol_version = ldap.VERSION3

    filter = ldap.filter.filter_format("(cn=%s)", (module, ))
    data = l.search_s (LDAP_BASE, ldap.SCOPE_SUBTREE, filter, None)

    return data



if __name__ == "__main__":
    (options, args) = parser.parse_args()
    tarballs = [file for file in args if os.path.exists(file)]

    if not len(tarballs):
        parser.print_usage()
        sys.exit(2)

    old_mask = os.umask(0002)
    groupid = grp.getgrnam(GROUP)[2]
    if groupid not in os.getgroups():
        print 'ERROR: Script requires membership of the %s group' % GROUP
        sys.exit(1)


    for file in tarballs:
        handler = InstallModule(file)
        handler.install(unattended=options.unattended)
