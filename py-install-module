#!/usr/bin/python

import sys
import os
import os.path
import grp
import pwd
import ldap
import ldap.filter
import re
import tempfile
import tarfile
import pprint
import difflib
import lzma # pyliblzma
from optparse import OptionParser
from email.mime.text import MIMEText
import smtplib
import json
import tempfile
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO


script_path = os.path.realpath(os.path.abspath(sys.argv[0]))
script_dir = os.path.dirname(script_path) + '/../gitadmin-bin'

sys.path.insert(0, '/home/admin/gitadmin-bin')
sys.path.insert(0, script_dir)


# Lives inside gitadmin-bin
import semi_rdf



DEBUG=True
#DEBUG=False
GROUP='ftpadmin'
LDAP_BASE='ou=modules,dc=gnome,dc=org'
re_file = re.compile(r'^(?P<module>.*?)[_-](?:(?P<oldversion>([0-9]+[\.])*[0-9]+)-)?(?P<version>([0-9]+[\.\-])*[0-9]+)\.(?P<format>(?:tar\.|diff\.)?[a-z][a-z0-9]*)$')
re_version = re.compile(r'^([0-9]+\.[0-9]+).*')
re_who = re.compile(r' <[^>]+>$')

usage = "usage: %prog [options] TARBALL"
description = """Install new tarball to GNOME FTP master and mirrors.

Example: install-module -u metacity-2.4.1.tar.gz

Report bugs to gnome-sysadmin@gnome.org"""

parser = OptionParser(usage=usage, description=description)
parser.add_option("-f", "--force", action="store_true", dest="clobber",
                          help="Overwrite the original tarball")
parser.add_option("-u", "--unattended", action="store_true",
        help="do not prompt for confirmation.\n\nNOTE: An unattended install " +
        "will not provide any extra information to help you avoid an invalid " +
        "(and potentially messy) installation. It is recommended that you do not " +
        "use this unless you are *very* sure.")

parser.set_defaults(clobber=False, unattended=False)

def version_cmp(a, b):
    """Compares two versions

    Returns
      -1 if a < b
      0  if a == b
      1  if a > b

    Important: only supports very specific versions (all numeric, separated by
    dots)"""
    a_nums = a.replace('-', '.0.').split('.')
    b_nums = b.replace('-', '.0.').split('.')
    num_fields = min(len(a_nums), len(b_nums))
    for i in range(0,num_fields):
        if   int(a_nums[i]) < int(b_nums[i]):
            return -1
        elif int(a_nums[i]) > int(b_nums[i]):
            return 1
    return cmp(len(a_nums), len(b_nums))

def get_latest_version(versions, max_version=None):
    """Gets the latest version number

    if max_version is specified, gets the latest version number before
    max_version"""
    latest = None
    for version in versions:
        if ( latest is None or version_cmp(version, latest) > 0 ) \
           and ( max_version is None or version_cmp(version, max_version) < 0 ):
            latest = version
    return latest

def human_size(size):
    suffixes = [("",2**10), ("K",2**20), ("M",2**30), ("G",2**40), ("T",2**50)]

    for suf, lim in suffixes:
        if size < lim:
            break

    sizediv = size/float(lim/2**10)
    if suf == "":
        fmt = "%0.0f%s"
    elif sizediv > 100:
        fmt = "%0.0f%s"
    elif sizediv > 10:
        fmt = "%0.1f%s"
    else:
        fmt = "%0.2f%s"

    return fmt % (size/float(lim/2**10), suf)

class BasicInfo(object):
    GROUPID = None

    FTPROOT='/ftp/pub/GNOME'
    URLROOT='http://download.gnome.org'


class TarInfo(BasicInfo):

    def __init__(self, path, files=set()):
        self.path = path
        self.file = {}

        self.dirname, self.basename = os.path.split(path)

        tarinfo_files = files.copy()

        r = re_file.match(self.basename)
        if r:
            fileinfo = r.groupdict()

            self.module = fileinfo['module']
            self.version = fileinfo['version']
            self.format = fileinfo['format']
            self.majmin = re_version.sub(r'\1', fileinfo['version'])

            tarinfo_files.add('%s-%s/ChangeLog' % (self.module, self.version))
            tarinfo_files.add('%s-%s/NEWS' % (self.module, self.version))
        else:
            self.module = None
            self.version = None
            self.format = None
            self.majmin = None

        self.files = tarinfo_files

    def check(self):
        """Check tarball consistency"""
        files = self.files

        t = tarfile.open(self.path, 'r', errors=2)
        size_files = 0
        file_count = 0
        uniq_dir = None
        for info in t:
            file_count += 1
            size_files += info.size

            if info.name in files:
                self.file[os.path.basename(info.name)] = t.extractfile(info).readlines()

            if file_count == 1 and info.isdir():
                uniq_dir = info.name
            elif uniq_dir is not None and not info.name.startswith(uniq_dir):
                uniq_dir = None

        # Now determine the current position in the tar file
        tar_end_of_data_pos = t.fileobj.tell()
        # as well as the last position in the tar file
        #t.fileobj.seek(0, os.SEEK_END)
        t.fileobj.read()
        tar_end_of_file_pos = t.fileobj.tell()
        t.close()

        self.size_files = size_files
        self.file_count = file_count
        self.tar_end_of_data_pos = tar_end_of_data_pos
        self.tar_end_of_file_pos = tar_end_of_file_pos
        self.uniq_dir = None


class ModuleInfo(BasicInfo):
    JSONVERSION = 0

    def __init__(self, modulename):
        self.module = modulename

        # Determine maintainers
        self.maintainers = []
        if self.module:
            data = get_module_info(self.module)
            if len(data):
                self.maintainers = data[0][1]['maintainerUid']

            self.jsonfile = os.path.join(self.FTPROOT, 'sources', self.module, '%s.json' % self.module)

        self.read_json()

    def refresh(self):
        if self.module is None: return False

        self.read_json(force_refresh=True)

    def read_json(self, force_refresh=False):
        if self.module is None:
            self.info = {}
            self.majmin = {}
            self.versions = []

            return False

        info = {}
        majmins = {}

        if not os.path.exists(self.jsonfile):
            force_refresh = True

        if not force_refresh:
            json_ver, json_info = json.load(open(self.jsonfile, 'r'))[:2]
            if json_ver == self.JSONVERSION:
                info = json_info
            elif json_ver > self.JSONVERSION:
                print "ERROR: Json newer than supported version, ignoring json"
                force_refresh=True
            else:
                force_refresh=True

        if DEBUG and not force_refresh:
            print "DEBUG: Forcing refresh of json (debug mode)"
            force_refresh = True

        if force_refresh:
            curdir = os.getcwd()
            try:
                # Ensures paths are relative to the FTPROOT
                os.chdir(self.FTPROOT)
                top = os.path.join('sources', self.module)
                for root, dirs, files in os.walk(top, topdown=False):
                    for filename in files:
                        r = re_file.match(filename)
                        if r:
                            fileinfo = r.groupdict()
                            module = fileinfo['module']
                            version = fileinfo['version']
                            format = fileinfo['format']

                            if module != self.module:
                                continue

                            info.setdefault(version, {})[format] = os.path.join(root, filename)
            finally:
                os.chdir(curdir)

        # XXX - maybe remove versions which lack tar.*

        # Group versions by major and minor number
        for version in info:
            majmin = re_version.sub(r'\1', version)
            if majmin not in majmins:
                majmins[majmin] = set()

            majmins[majmin].add(version)

        self.info = info
        self.majmin = majmins
        self.versions = sorted(info, version_cmp)


    def determine_file(self, version, format):
        """Determine file using version and format

        Might return a compressed version of the given format.

        Returns None if format cannot be found"""
        if version not in self.info:
            return None

        formats = [format]
        formats.extend(("%s.%s" % (format, compression) for compression in ("gz", "bz2", "xz")))

        info_formats = self.info[version]
        for f in formats:
            if f in info_formats:
                return os.path.join(self.FTPROOT, info_formats[f])

        return None

    def info_detailed(self, version, format):
        """Provides detailed information about file references by
        version and format.

        Will NOT return a posibly compressed version."""
        if version not in self.info:
            return None

        info = self.info[version].get(format, None)
        if info is None:
            return None

        realpath = os.path.join(self.FTPROOT, info)
        stat = os.stat(realpath)
        return (info, realpath, human_size(stat.st_size), stat)


    def write_json(self): # XXX - should write json
        if self.module is None: return False

        info = self.info
        json.dump((self.JSONVERSION, info), open(self.jsonfile, 'w'))
        if self.GROUPID is not None:
            os.chown(self.jsonfile, -1, self.GROUPID)


class InstallModule(BasicInfo):
    FORMATS = ('tar.gz', 'tar.bz2')

    def __init__(self, file):
        self.file = file

        self.uid = os.getuid()
        self.pw = pwd.getpwuid(self.uid)
        self.who = self.pw.pw_gecos
        self.who = re_who.sub("", self.who)

        self.dirname, self.basename = os.path.split(file)
        self.fileinfo = TarInfo(file)

        if self.fileinfo.module is not None:
            self.module = self.fileinfo.module
            self.majmin = self.fileinfo.majmin
            self.version = self.fileinfo.version
            self.format = self.fileinfo.format

            self.destination = '%s/sources/%s/%s' % (self.FTPROOT, self.fileinfo.module, self.majmin)

        self.moduleinfo = ModuleInfo(self.fileinfo.module)
        self.moduleinfo.write_json()
        self.prevversion = get_latest_version(self.moduleinfo.versions, self.version)



    def confirm_install(self):

        print """      Module: %s
     Version: %s   (previous version: %s)
     Maj.Min: %s
 Destination: %s/""" % (self.module, self.version, self.prevversion or 'N/A', self.majmin, self.destination)

        # Check if the module directory already exists. If not, the module name might contain a typo
        if not os.path.isdir('%s/sources/%s' % (self.FTPROOT, self.module)):
            print """
WARNING: %s is not present in the archive!
         Are you sure that it is new and/or the correct module name?""" % self.module

        print """
Install %s? [Y/n]""" % self.module,
        response = raw_input()

        if response != '' and response[0] != 'y' and response[0] != 'Y':
            print """Module installation cancelled. Please report any problems with this
script to gnome-sysadmin@gnome.org. Thanks."""

            return False

        # install the module
        return True

    def validate(self):
        if self.module is None:
            print 'ERROR: Unrecognized module/version/file format. Make sure to follow a sane naming scheme (MAJOR.MINOR.MICRO)'
            return False

        # Don't allow an existing tarball to be overwritten
        if os.path.exists(os.path.join(self.destination, self.basename)):
            print """ERROR: %s already exists in the archive!""" % self.basename
            if DEBUG:
                print "DEBUG: Continuing anyway in debug mode"
            else:
                return False

        # XXX - verify if tarball is being installed by a maintainer

        # CHECK FOR CONSISTENCY

        errors = self.fileinfo.check()

        tar = tarfile.open(self.file)

        # CHECK 1: Make sure tarball contains a directory called $MODULE-$VERSION
        dir = None
        try:
            dir = tar.getmember('%s-%s' % (self.module, self.version))
        except KeyError:
            pass
        if dir and not dir.isdir():
            dir = None
        if dir is None:
            print 'ERROR: Cannot find expected directory within tarball, aborting!'
            return False

        # Valid file
        return True

    def install(self, unattended=False):
        # Validate the file
        if not self.validate():
            return False


        # Ask user if tarball should be installed
        if not unattended:
            if not self.confirm_install():
                return False


#        for k, v in self.__dict__.iteritems():
#            print k, v

        if self.prevversion:
            prev_file = self.moduleinfo.determine_file(self.prevversion, 'tar')
            if prev_file:
                prev_fileinfo = TarInfo(prev_file)
                prev_errors = prev_fileinfo.check()
                if prev_errors:
                    prev_file = None

            for fn in self.fileinfo.file:
                if prev_file is not None and fn in prev_fileinfo.file:
                    context = 0
                    a = prev_fileinfo.file[fn]
                    b = self.fileinfo.file[fn]
                    for group in difflib.SequenceMatcher(None,a,b).get_grouped_opcodes(context):
                        i1, i2, j1, j2 = group[0][1], group[-1][2], group[0][3], group[-1][4]
                        for tag, i1, i2, j1, j2 in group:
                            if tag == 'replace' or tag == 'insert':
                                for line in b[j1:j2]:
                                    # XXX - write correct file
#                                    print line,
                                    pass
                else:
                    for line in self.fileinfo.file[fn]:
                        # XXX - write correct file
                        print line,

#        if not os.path.isdir(self.destination):
#            os.makedirs(self.destination, 042775) # drwxrwsr-x
        # XXX - install the tarball
        # XXX - change ownership of the tarball

            self.inform()

    def inform(self):
        """Inform regarding the new release"""
        if self.version in self.moduleinfo.info:
            sha256sum = {}

            mail = StringIO()


            info = self.moduleinfo.info_detailed(self.version, 'sha256sum')
            if info is not None:
                path, realpath, size, stat = info
                with open(realpath, "r") as f:
                    for line in f.read().splitlines():
                        # XXX - the checksum filed could look differently (binary indicator)
                        if '  ' in line:
                            checksum, file = line.partition('  ')[::2]
                            sha256sum[file] = checksum
                        else:
                            print "WARN: Strange sha256sum line: %s" % line
            else:
                print "WARN: Couldn't determine sha256sum file?!?"

            print >>mail, """       Module: %s
      Version: %s
  Uploaded by: %s
""" % (self.module, self.version, self.who)

            for format in self.FORMATS:
                info = self.moduleinfo.info_detailed(self.version, format)
                if info is not None:
                    path, realpath, size, stat = info
                    dirname, basename = os.path.split(path)
                    print >>mail, "%s/%s" % (self.URLROOT, path)
                    if basename in sha256sum:
                        print >>mail, " sha256sum: %s" % sha256sum[basename]
                    print >>mail, "      size: %s" % size
                    print >>mail, ""

            dump_files = [
                ('news', 'News'),
                ('changes', 'ChangeLog')
            ]

            for format, formatname in dump_files:
                info = self.moduleinfo.info_detailed(self.version, format)
                if info is not None:
                    path, realpath, size, stat = info
                    print >>mail, formatname
                    print >>mail, "-" * len(formatname)
                    print >>mail, ""
                    if stat.st_size > 50000:
                        mail.write("%s/%s" % (self.URLROOT, path))
                    else:
                        mail.write(open(realpath, 'r').read())
                    print >>mail, ""


            mail.seek(0)
            msg = MIMEText(mail.read(), _charset='utf-8')
            msg['Subject'] = '%s %s' % (self.module, self.version)
            msg['From'] = '"%s" <install-module@master.gnome.org>' % self.who
            msg['To'] = "FTP Releases <ftp-release-list@gnome.org>"
            s = smtplib.SMTP()
            s.connect()
            s.sendmail('install-module@master.gnome.org', ['olav@vitters.nl'], msg.as_string())
            s.quit()





l = None
def get_module_info(module):
    global l # evil

    if l is None:
        l = ldap.open('ldap-back')
        l.protocol_version = ldap.VERSION3

    filter = ldap.filter.filter_format("(cn=%s)", (module, ))
    data = l.search_s (LDAP_BASE, ldap.SCOPE_SUBTREE, filter, None)

    return data



if __name__ == "__main__":
    (options, args) = parser.parse_args()
    tarballs = [file for file in args if os.path.exists(file)]

    if not len(tarballs):
        parser.print_usage()
        sys.exit(2)

    old_mask = os.umask(0002)
    groupid = grp.getgrnam(GROUP)[2]
    if groupid not in os.getgroups():
        print 'ERROR: Script requires membership of the %s group' % GROUP
        sys.exit(1)

    BasicInfo.GROUPID = groupid

    for file in tarballs:
        handler = InstallModule(file)
        handler.install(unattended=options.unattended)
