#!/usr/bin/python -u

import sys
import os
import os.path
import grp
import pwd
import ldap
import ldap.filter
import re
import tempfile
import tarfile
import pprint
import difflib
import shutil
import gzip
import bz2
import lzma # pyliblzma
import subprocess
from optparse import OptionParser
from email.mime.text import MIMEText
import json
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO


script_path = os.path.realpath(os.path.abspath(sys.argv[0]))
script_dir = os.path.dirname(script_path) + '/../gitadmin-bin'

sys.path.insert(0, '/home/admin/gitadmin-bin')
sys.path.insert(0, script_dir)


# Lives inside gitadmin-bin
import semi_rdf



DEBUG=True
#DEBUG=False
GROUP='ftpadmin'
LDAP_BASE='ou=modules,dc=gnome,dc=org'
re_file = re.compile(r'^(?P<module>.*?)[_-](?:(?P<oldversion>([0-9]+[\.])*[0-9]+)-)?(?P<version>([0-9]+[\.\-])*[0-9]+)\.(?P<format>(?:tar\.|diff\.)?[a-z][a-z0-9]*)$')
re_version = re.compile(r'^([0-9]+\.[0-9]+).*')
re_who = re.compile(r' <[^>]+>$')

usage = "usage: %prog [options] TARBALL"
description = """Install new tarball to GNOME FTP master and mirrors.

Example: install-module -u metacity-2.4.1.tar.gz

Report bugs to gnome-sysadmin@gnome.org"""

parser = OptionParser(usage=usage, description=description)
parser.add_option("-f", "--force", action="store_true", dest="clobber",
                          help="Overwrite the original tarball")
parser.add_option("-u", "--unattended", action="store_true",
        help="do not prompt for confirmation.\n\nNOTE: An unattended install " +
        "will not provide any extra information to help you avoid an invalid " +
        "(and potentially messy) installation. It is recommended that you do not " +
        "use this unless you are *very* sure.")

parser.set_defaults(clobber=False, unattended=False)

def version_cmp(a, b):
    """Compares two versions

    Returns
      -1 if a < b
      0  if a == b
      1  if a > b

    Important: only supports very specific versions (all numeric, separated by
    dots)"""
    a_nums = a.replace('-', '.0.').split('.')
    b_nums = b.replace('-', '.0.').split('.')
    num_fields = min(len(a_nums), len(b_nums))
    for i in range(0,num_fields):
        if   int(a_nums[i]) < int(b_nums[i]):
            return -1
        elif int(a_nums[i]) > int(b_nums[i]):
            return 1
    return cmp(len(a_nums), len(b_nums))

def get_latest_version(versions, max_version=None):
    """Gets the latest version number

    if max_version is specified, gets the latest version number before
    max_version"""
    latest = None
    for version in versions:
        if ( latest is None or version_cmp(version, latest) > 0 ) \
           and ( max_version is None or version_cmp(version, max_version) < 0 ):
            latest = version
    return latest

def human_size(size):
    suffixes = [("",2**10), ("K",2**20), ("M",2**30), ("G",2**40), ("T",2**50)]

    for suf, lim in suffixes:
        if size < lim:
            break

    sizediv = size/float(lim/2**10)
    if suf == "":
        fmt = "%0.0f%s"
    elif sizediv > 100:
        fmt = "%0.0f%s"
    elif sizediv > 10:
        fmt = "%0.1f%s"
    else:
        fmt = "%0.2f%s"

    return fmt % (size/float(lim/2**10), suf)

class BasicInfo(object):
    GROUPID = None

    FTPROOT='/ftp/pub/GNOME'
    URLROOT='http://download.gnome.org'
    BLOCKSIZE=5248000 # 5MB (dot will be printed per block)

    # Note: this defines the formats install-module can read
    #       formats install-module creates is defined in 
    #       ModuleInstall.INSTALL_FORMATS
    FORMATS = {
        'tar.gz': gzip.GzipFile,
        'tar.bz2': bz2.BZ2File,
        'tar.xz': lzma.LZMAFile
    }

class TarInfo(BasicInfo):

    def __init__(self, path, files=set()):
        self.path = path
        self.file = {}

        self.dirname, self.basename = os.path.split(path)

        tarinfo_files = files.copy()

        r = re_file.match(self.basename)
        if r:
            fileinfo = r.groupdict()

            self.module = fileinfo['module']
            self.version = fileinfo['version']
            self.format = fileinfo['format']
            self.majmin = re_version.sub(r'\1', fileinfo['version'])

            tarinfo_files.add('%s-%s/ChangeLog' % (self.module, self.version))
            tarinfo_files.add('%s-%s/NEWS' % (self.module, self.version))
        else:
            self.module = None
            self.version = None
            self.format = None
            self.majmin = None

        self.files = tarinfo_files

    def check(self, progress=False):
        """Check tarball consistency"""
        errors = {}
        files = self.files

        # XXX  - this will automatically decompress bz2 and gz tarballs.. However,
        #        xz is NOT handled. Should wrap this using self.FORMATS
        t = tarfile.open(self.path, 'r', errors=2)
        try:
            size_files = 0
            file_count = 0
            uniq_dir = None
            dots_shown = 0
            for info in t:
                file_count += 1
                size_files += info.size

                if info.name in files:
                    self.file[os.path.basename(info.name)] = t.extractfile(info).readlines()

                if file_count == 1 and info.isdir():
                    uniq_dir = "%s/" % info.name
                elif uniq_dir is not None and not info.name.startswith(uniq_dir):
                    uniq_dir = None
                if progress:
                    dots_to_show = t.offset / self.BLOCKSIZE
                    if dots_to_show > dots_shown:
                        sys.stdout.write("." * (dots_to_show - dots_shown))
                        dots_shown = dots_to_show

            # Now determine the current position in the tar file
            tar_end_of_data_pos = t.fileobj.tell()
            # as well as the last position in the tar file
            # Note: doing a read as seeking is often not supported :-(
            t.fileobj.read()
            tar_end_of_file_pos = t.fileobj.tell()


            test_uniq_dir = '%s-%s/' % (self.module, self.version)
            if uniq_dir is None:
                errors['NO_UNIQ_DIR'] = 'Files should all be in one directory (%s)' % test_uniq_dir
            elif uniq_dir != test_uniq_dir:
                errors['UNIQ_DIR'] = 'Files not in the correct directory (expected %s, found %s)' % (test_uniq_dir, uniq_dir)

            test_eof_data = (tar_end_of_file_pos - tar_end_of_data_pos)
            MAX_EXTRA_DATA=8192
            if test_eof_data > MAX_EXTRA_DATA:
                errors['EXTRA_DATA'] = 'Tarball has too much extra data (expected max %s, found %s)' % (human_size(MAX_EXTRA_DATA), human_size(test_eof_data))

            self.size_files = size_files
            self.file_count = file_count
            self.tar_end_of_data_pos = tar_end_of_data_pos
            self.tar_end_of_file_pos = tar_end_of_file_pos
            self.uniq_dir = uniq_dir
        finally:
            t.close()

        # XXX  - actually validate the tarball and return errors
        return errors


class ModuleInfo(BasicInfo):
    JSONVERSION = 0

    def __init__(self, modulename):
        self.module = modulename

        # Determine maintainers
        self.maintainers = []
        if self.module:
            data = get_module_info(self.module)
            if len(data):
                self.maintainers = data[0][1]['maintainerUid']

            self.jsonfile = os.path.join(self.FTPROOT, 'sources', self.module, '%s.json' % self.module)

        self.read_json()

    def refresh(self):
        if self.module is None: return False

        self.read_json(force_refresh=True)

    def read_json(self, force_refresh=False):
        if self.module is None:
            self.info = {}
            self.majmin = {}
            self.versions = []

            return False

        info = {}
        majmins = {}
        changed = False

        if not os.path.exists(self.jsonfile):
            force_refresh = True

        if not force_refresh:
            json_ver, json_info = json.load(open(self.jsonfile, 'rb'))[:2]
            if json_ver == self.JSONVERSION:
                info = json_info
                if not len(info):
                    force_refresh=True
            elif json_ver > self.JSONVERSION:
                print "ERROR: Json newer than supported version, ignoring json"
                force_refresh=True
            else:
                force_refresh=True

        if DEBUG and not force_refresh:
            force_refresh = True

        if force_refresh and os.path.exists(self.FTPROOT):
            curdir = os.getcwd()
            try:
                # Ensures paths are relative to the FTPROOT
                os.chdir(self.FTPROOT)
                top = os.path.join('sources', self.module)
                for root, dirs, files in os.walk(top, topdown=False):
                    for filename in files:
                        r = re_file.match(filename)
                        if r:
                            changed = True

                            fileinfo = r.groupdict()
                            module = fileinfo['module']
                            version = fileinfo['version']
                            format = fileinfo['format']

                            if module != self.module:
                                continue

                            info.setdefault(version, {})[format] = os.path.join(root, filename)
            finally:
                os.chdir(curdir)

        # XXX - maybe remove versions which lack tar.*

        # Group versions by major and minor number
        for version in info:
            majmin = re_version.sub(r'\1', version)
            if majmin not in majmins:
                majmins[majmin] = set()

            majmins[majmin].add(version)

        self.info = info
        self.majmin = majmins
        self.versions = sorted(info, version_cmp)

        if changed:
            # save the new information
            self.write_json()

    def determine_file(self, version, format):
        """Determine file using version and format

        Might return a compressed version of the given format.

        Returns None if format cannot be found"""
        if version not in self.info:
            return None

        formats = [format]
        formats.extend(("%s.%s" % (format, compression) for compression in ("gz", "bz2", "xz")))

        info_formats = self.info[version]
        for f in formats:
            if f in info_formats:
                return os.path.join(self.FTPROOT, info_formats[f])

        return None

    def info_detailed(self, version, format):
        """Provides detailed information about file references by
        version and format.

        Will NOT return a posibly compressed version."""
        if version not in self.info:
            return None

        info = self.info[version].get(format, None)
        if info is None:
            return None

        realpath = os.path.join(self.FTPROOT, info)
        stat = os.stat(realpath)
        return (info, realpath, human_size(stat.st_size), stat)


    def write_json(self):
        if self.module is None: return False

        info = self.info
        json.dump((self.JSONVERSION, info), open(self.jsonfile, 'w'))
        if self.GROUPID is not None:
            os.chown(self.jsonfile, -1, self.GROUPID)


class InstallModule(BasicInfo):

    INSTALL_FORMATS = ('tar.gz', 'tar.bz2')

    def __init__(self, file):
        self.file = file

        self.uid = os.getuid()
        self.pw = pwd.getpwuid(self.uid)
        self.who = self.pw.pw_gecos
        self.who = re_who.sub("", self.who)
        if self.who == "":
            self.who = self.pw.pw_name

        self.dirname, self.basename = os.path.split(file)
        self.fileinfo = TarInfo(file)

        if self.fileinfo.module is not None:
            self.module = self.fileinfo.module
            self.majmin = self.fileinfo.majmin
            self.version = self.fileinfo.version
            self.format = self.fileinfo.format

            self.destination = '%s/sources/%s/%s' % (self.FTPROOT, self.fileinfo.module, self.majmin)

        self.moduleinfo = ModuleInfo(self.fileinfo.module)
        self.prevversion = get_latest_version(self.moduleinfo.versions, self.version)



    def confirm_install(self):

        print """      Module: %s
     Version: %s   (previous version: %s)
 Destination: %s/""" % (self.module, self.version, self.prevversion or 'N/A', self.destination)

        # Check if the module directory already exists. If not, the module name might contain a typo
        if not os.path.isdir('%s/sources/%s' % (self.FTPROOT, self.module)):
            print """
WARNING: %s is not present in the archive!
         Are you sure that it is new and/or the correct module name?""" % self.module

        print """
Install %s? [Y/n]""" % self.module,
        response = raw_input()

        if response != '' and response[0] != 'y' and response[0] != 'Y':
            print """Module installation cancelled. Please report any problems with this
script to gnome-sysadmin@gnome.org. Thanks."""

            return False

        # install the module
        return True

    def validate(self):
        if self.module is None:
            print 'ERROR: Unrecognized module/version/file format. Make sure to follow a sane naming scheme (MAJOR.MINOR.MICRO)'
            return False

        # Don't allow an existing tarball to be overwritten
        if os.path.exists(os.path.join(self.destination, self.basename)):
            print """ERROR: %s already exists in the archive!""" % self.basename
            if DEBUG:
                print "DEBUG: Continuing anyway in debug mode"
            else:
                return False

        # XXX - verify if tarball is being installed by a maintainer

        # CHECK FOR CONSISTENCY
        sys.stdout.write("Checking consistency %s: " % self.file)
        errors = self.fileinfo.check(progress=True)
        if not errors:
            print ", done"
        else:
            print ", failed"
            for k, v in errors.iteritems():
                print "ERROR: %s" % v

        # True if there are no errors
        return len(errors) == 0

    def install(self, unattended=False):
        # Validate the file
        if not self.validate():
            return False


        # Ask user if tarball should be installed
        if not unattended:
            if not self.confirm_install():
                return False


#        for k, v in self.__dict__.iteritems():
#            print k, v

        tmpdir = tempfile.mkdtemp(prefix='install_module')
        try:
            print "Creating new files:"
            created_files = []
            # do we have a previous version?
            prev_errors = True # pretend there are error unless proved otherwise
            if self.prevversion:
                prev_file = self.moduleinfo.determine_file(self.prevversion, 'tar')
            else:
                prev_file = None

            if prev_file:
                # validate the previous file
                prev_fileinfo = TarInfo(prev_file)
                sys.stdout.write(" - Checking previous tarball: ")
                prev_errors = prev_fileinfo.check(progress=True)
                if not prev_errors:
                    print ", done"
                else:
                    print ", failed (ignoring previous tarball!)"
                    # only diff against the previous version is there are no errors
                    prev_file = None

            for fn in self.fileinfo.file:
                sys.stdout.write(" - %s" % fn)
                with self._make_tmp_file(tmpdir, fn) as f:
                    if prev_file is not None and fn in prev_fileinfo.file:
                        context = 0
                        a = prev_fileinfo.file[fn]
                        b = self.fileinfo.file[fn]
                        break_for = False
                        lines = 0
                        for group in difflib.SequenceMatcher(None,a,b).get_grouped_opcodes(context):
                            i1, i2, j1, j2 = group[0][1], group[-1][2], group[0][3], group[-1][4]
                            for tag, i1, i2, j1, j2 in group:
                                if tag == 'replace' or tag == 'insert':
                                    lines += j2 - j1
                                    f.writelines(b[j1:j2])
                                    break_for = True
                            if break_for:
                                break
                        if lines > 2:
                            created_files.append(f.name)
                            print ", done (diff, %s lines)" % lines
                        else:
                            print ", ignored (no change)"
                            os.remove(f.name)
                    elif not prev_errors:
                        # succesfully read previous tarball, didn't find a 'NEWS' / 'ChangeLog'
                        # assume file has been added in this release and no diff is needed
                        f.writelines(self.fileinfo.file[fn])
                        created_files.append(f.name)
                        print ", done (new file)"
                    else:
                        print ", ignored (previous tarball is not valid)"


            # Create tarball(s) according to INSTALL_FORMATS
            if self.format in self.INSTALL_FORMATS:
                sys.stdout.write(" - Copying %s" % self.format)
                with open(self.file, 'rb') as f1:
                    with self._make_tmp_file(tmpdir, self.format) as f2:
                        created_files.append(f2.name)
                        shutil.copyfileobj(f1, f2)
                print ", done"

            formats = [format for format in self.INSTALL_FORMATS if format != self.format]
            if len(formats):
                if len(formats) == 1:
                    sys.stdout.write(" - Creating %s from %s: " % (formats[0], self.format))
                else:
                    sys.stdout.write(" - Creating tarballs from %s: " % self.format)
                f2 = []
                for format in formats:
                    if len(formats) > 1:
                        sys.stdout.write("%s " % format)
                    f = self._make_tmp_file(tmpdir, format, constructor=self.FORMATS[format])
                    created_files.append(f.name)
                    f2.append(f)

                f1 = self.FORMATS[self.format](self.file, 'rb')
                while 1:
                    buf = f1.read(self.BLOCKSIZE)
                    if not buf:
                        break
                    for fdst in f2:
                        fdst.write(buf)
                        sys.stdout.write(".")
                for fdst in f2:
                    fdst.close()
                    f2 = []
                print ", done"



            sys.stdout.write(" - Creating sha256sum")
            with self._make_tmp_file(tmpdir, 'sha256sum') as f:
                cmd = ['sha256sum', '--']
                cmd.extend([os.path.basename(fn) for fn in created_files if os.path.isfile(fn)])
                subprocess.call(cmd, stdout=f, cwd=tmpdir)
            print ", done"

        #        if not os.path.isdir(self.destination):
        #            os.makedirs(self.destination, 042775) # drwxrwsr-x
                # XXX - install the tarball
                # XXX - change ownership of the tarball
                # XXX - refresh version information
                # self.moduleinfo.refresh(force_refresh=True)
        finally:
            # cleanup temporary directory
            if not DEBUG:
                shutil.rmtree(tmpdir)
            else:
                print "DEBUG: Not removing temporary directory: %s" % tmpdir

        self.inform()

    def _make_tmp_file(self, tmpdir, format, constructor=open):
        fn = os.path.join(tmpdir, '%s-%s.%s' % (self.module, self.version, format))
        f = constructor(fn, 'w')
        if self.GROUPID is not None:
            os.chown(fn, -1, self.GROUPID)
        return f

    def inform(self):
        """Inform regarding the new release"""
        print "Doing notifications:"
        if self.version not in self.moduleinfo.info:
            return False

        sha256sum = {}
        sys.stdout.write(" - Informing ftp-release-list")

        mail = StringIO()

        info = self.moduleinfo.info_detailed(self.version, 'sha256sum')
        if info is not None:
            path, realpath, size, stat = info
            with open(realpath, "r") as f:
                for line in f.read().splitlines():
                    # XXX - the checksum filed could look differently (binary indicator)
                    if '  ' in line:
                        checksum, file = line.partition('  ')[::2]
                        sha256sum[file] = checksum
                    else:
                        print "WARN: Strange sha256sum line: %s" % line
        else:
            print "WARN: Couldn't determine sha256sum file?!?"

        print >>mail, """       Module: %s
      Version: %s
  Uploaded by: %s
""" % (self.module, self.version, self.who)

        for format in self.FORMATS:
            info = self.moduleinfo.info_detailed(self.version, format)
            if info is not None:
                path, realpath, size, stat = info
                dirname, basename = os.path.split(path)
                print >>mail, "%s/%s" % (self.URLROOT, path)
                if basename in sha256sum:
                    print >>mail, " sha256sum: %s" % sha256sum[basename]
                print >>mail, "      size: %s" % size
                print >>mail, ""

        dump_files = [
            ('news', 'News'),
            ('changes', 'ChangeLog')
        ]
        show_contents = True
        for format, formatname in dump_files:
            info = self.moduleinfo.info_detailed(self.version, format)
            if info is not None:
                path, realpath, size, stat = info
                if show_contents and stat.st_size < 50000:
                    with open(realpath, 'r') as f:
                        line = f.readline()
                        if not self.version in line:
                            print >>mail, formatname
                            print >>mail, "-" * len(formatname)
                            print >>mail, ""
                        mail.write(line)
                        shutil.copyfileobj(f, mail)
                else:
                    print >>mail, formatname
                    print >>mail, "-" * len(formatname)
                    mail.write("%s/%s  (%s)" % (self.URLROOT, path, size))
                print >>mail, ""
                # Only show the contents of the first found file, URLs for the rest
                show_contents = False


        mail.seek(0)
        subject = '%s %s' % (self.module, self.version)
        to = "FTP Releases <ftp-release-list@gnome.org>"
        retcode = self._send_email(mail.read(), subject, to, ['olav@vitters.nl'])
        print ", done"

        sys.stdout.write(" - Triggering GNOME library update")
        subject = 'GNOME_GIT library-web'
        to = "gnomeweb@www.gnome.org"
        retcode = self._send_email("forced", subject, to, ['olav@vitters.nl'])
        print ", done"

        sys.stdout.write(" - Adding new version to GNOME Bugzilla")
        cmd = ['/usr/bin/curl', '-L', 'https://bugzilla.gnome.org/add-version.cgi?%s|%s' % (self.module, self.version)]
        self._call_progress(cmd)

        sys.stdout.write(" - Triggering ftp.gnome.org update")
        syncscript = ['/usr/local/bin/signal-ftp-sync']
        if self._call_progress(cmd):
            print ""
            print "Your tarball will appear in the following location on ftp.gnome.org:"
            print ""
            print "  %s" % "/".join((self.URLROOT, 'sources', self.module, self.majmin, ""))
            print ""
            print "It is important to retain the trailing slash for compatibility with"
            print "broken http clients, and to use http as it is less taxing on the server."
            info = self.moduleinfo.info_detailed(self.version, 'sha256sum')
            if info is not None:
                print ""
                path, realpath, size, stat = info
                with open(realpath, "r") as f:
                    shutil.copyfileobj(f, sys.stdout)


    def _call_progress(self, cmd):
        status = False
        if os.path.isfile(cmd[0]):
            status = True
            if not DEBUG:
                retcode = subprocess.call(cmd)
                print "done (exit code %s)" % retcode
            else:
                print ", ignored (debug mode)"
        else:
            print ", FAILED (cannot find %s)" % cmd[0]
            print "PLEASE INFORM gnome-sysadmin@gnome.org ASAP!!!"

        return status


    def _send_email(self, contents, subject, to, smtp_to):
        msg = MIMEText(contents, _charset='utf-8')
        msg['Subject'] = subject
        msg['From'] = '"%s" <install-module@master.gnome.org>' % self.who
        msg['To'] = to

        if DEBUG:
            smtp_to = ['olav@vitters.nl']

        cmd = ['/usr/sbin/sendmail', '-oi', '-f', 'install-module@master.gnome.org', '--']
        cmd.extend(smtp_to)
        p = subprocess.Popen(cmd, stdin=subprocess.PIPE)
        p.stdin.write(msg.as_string())
        p.stdin.flush()
        p.stdin.close()
        return p.wait()





l = None
def get_module_info(module):
    global l # evil

    if l is None:
        l = ldap.open('ldap-back')
        l.protocol_version = ldap.VERSION3

    filter = ldap.filter.filter_format("(cn=%s)", (module, ))
    data = l.search_s (LDAP_BASE, ldap.SCOPE_SUBTREE, filter, None)

    return data



if __name__ == "__main__":
    (options, args) = parser.parse_args()
    tarballs = [file for file in args if os.path.exists(file)]

    if not len(tarballs):
        parser.print_usage()
        sys.exit(2)

    old_mask = os.umask(0002)
    groupid = grp.getgrnam(GROUP)[2]
    if groupid not in os.getgroups():
        print 'ERROR: Script requires membership of the %s group' % GROUP
        sys.exit(1)

    BasicInfo.GROUPID = groupid

    for file in tarballs:
        sys.stdout.write("Checking for info about %s" % file)
        handler = InstallModule(file)
        print ", done"
        handler.install(unattended=options.unattended)
