#!/usr/bin/python -u

import sys
import os
import os.path
import grp
import pwd
import ldap
import ldap.filter
import re
import tempfile
import tarfile
import pprint
import difflib
import shutil
import gzip
import bz2
import lzma # pyliblzma
from optparse import OptionParser
from email.mime.text import MIMEText
import smtplib
import json
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO


script_path = os.path.realpath(os.path.abspath(sys.argv[0]))
script_dir = os.path.dirname(script_path) + '/../gitadmin-bin'

sys.path.insert(0, '/home/admin/gitadmin-bin')
sys.path.insert(0, script_dir)


# Lives inside gitadmin-bin
import semi_rdf



DEBUG=True
#DEBUG=False
GROUP='ftpadmin'
LDAP_BASE='ou=modules,dc=gnome,dc=org'
re_file = re.compile(r'^(?P<module>.*?)[_-](?:(?P<oldversion>([0-9]+[\.])*[0-9]+)-)?(?P<version>([0-9]+[\.\-])*[0-9]+)\.(?P<format>(?:tar\.|diff\.)?[a-z][a-z0-9]*)$')
re_version = re.compile(r'^([0-9]+\.[0-9]+).*')
re_who = re.compile(r' <[^>]+>$')

usage = "usage: %prog [options] TARBALL"
description = """Install new tarball to GNOME FTP master and mirrors.

Example: install-module -u metacity-2.4.1.tar.gz

Report bugs to gnome-sysadmin@gnome.org"""

parser = OptionParser(usage=usage, description=description)
parser.add_option("-f", "--force", action="store_true", dest="clobber",
                          help="Overwrite the original tarball")
parser.add_option("-u", "--unattended", action="store_true",
        help="do not prompt for confirmation.\n\nNOTE: An unattended install " +
        "will not provide any extra information to help you avoid an invalid " +
        "(and potentially messy) installation. It is recommended that you do not " +
        "use this unless you are *very* sure.")

parser.set_defaults(clobber=False, unattended=False)

def version_cmp(a, b):
    """Compares two versions

    Returns
      -1 if a < b
      0  if a == b
      1  if a > b

    Important: only supports very specific versions (all numeric, separated by
    dots)"""
    a_nums = a.replace('-', '.0.').split('.')
    b_nums = b.replace('-', '.0.').split('.')
    num_fields = min(len(a_nums), len(b_nums))
    for i in range(0,num_fields):
        if   int(a_nums[i]) < int(b_nums[i]):
            return -1
        elif int(a_nums[i]) > int(b_nums[i]):
            return 1
    return cmp(len(a_nums), len(b_nums))

def get_latest_version(versions, max_version=None):
    """Gets the latest version number

    if max_version is specified, gets the latest version number before
    max_version"""
    latest = None
    for version in versions:
        if ( latest is None or version_cmp(version, latest) > 0 ) \
           and ( max_version is None or version_cmp(version, max_version) < 0 ):
            latest = version
    return latest

def human_size(size):
    suffixes = [("",2**10), ("K",2**20), ("M",2**30), ("G",2**40), ("T",2**50)]

    for suf, lim in suffixes:
        if size < lim:
            break

    sizediv = size/float(lim/2**10)
    if suf == "":
        fmt = "%0.0f%s"
    elif sizediv > 100:
        fmt = "%0.0f%s"
    elif sizediv > 10:
        fmt = "%0.1f%s"
    else:
        fmt = "%0.2f%s"

    return fmt % (size/float(lim/2**10), suf)

class BasicInfo(object):
    GROUPID = None

    FTPROOT='/ftp/pub/GNOME'
    URLROOT='http://download.gnome.org'

    # Note: this defines the formats install-module can read
    #       formats install-module creates is defined in 
    #       ModuleInstall.INSTALL_FORMATS
    FORMATS = {
        'tar.gz': gzip.GzipFile,
        'tar.bz2': bz2.BZ2File,
        'tar.xz': lzma.LZMAFile
    }

class TarInfo(BasicInfo):

    def __init__(self, path, files=set()):
        self.path = path
        self.file = {}

        self.dirname, self.basename = os.path.split(path)

        tarinfo_files = files.copy()

        r = re_file.match(self.basename)
        if r:
            fileinfo = r.groupdict()

            self.module = fileinfo['module']
            self.version = fileinfo['version']
            self.format = fileinfo['format']
            self.majmin = re_version.sub(r'\1', fileinfo['version'])

            tarinfo_files.add('%s-%s/ChangeLog' % (self.module, self.version))
            tarinfo_files.add('%s-%s/NEWS' % (self.module, self.version))
        else:
            self.module = None
            self.version = None
            self.format = None
            self.majmin = None

        self.files = tarinfo_files

    def check(self):
        """Check tarball consistency"""
        files = self.files

        t = tarfile.open(self.path, 'r', errors=2)
        size_files = 0
        file_count = 0
        uniq_dir = None
        for info in t:
            file_count += 1
            size_files += info.size

            if info.name in files:
                self.file[os.path.basename(info.name)] = t.extractfile(info).readlines()

            if file_count == 1 and info.isdir():
                uniq_dir = info.name
            elif uniq_dir is not None and not info.name.startswith(uniq_dir):
                uniq_dir = None

        # Now determine the current position in the tar file
        tar_end_of_data_pos = t.fileobj.tell()
        # as well as the last position in the tar file
        # Note: doing a read as seeking is often not supported :-(
        t.fileobj.read()
        tar_end_of_file_pos = t.fileobj.tell()
        t.close()

        self.size_files = size_files
        self.file_count = file_count
        self.tar_end_of_data_pos = tar_end_of_data_pos
        self.tar_end_of_file_pos = tar_end_of_file_pos
        self.uniq_dir = None


class ModuleInfo(BasicInfo):
    JSONVERSION = 0

    def __init__(self, modulename):
        self.module = modulename

        # Determine maintainers
        self.maintainers = []
        if self.module:
            data = get_module_info(self.module)
            if len(data):
                self.maintainers = data[0][1]['maintainerUid']

            self.jsonfile = os.path.join(self.FTPROOT, 'sources', self.module, '%s.json' % self.module)

        self.read_json()

    def refresh(self):
        if self.module is None: return False

        self.read_json(force_refresh=True)

    def read_json(self, force_refresh=False):
        if self.module is None:
            self.info = {}
            self.majmin = {}
            self.versions = []

            return False

        info = {}
        majmins = {}
        changed = False

        if not os.path.exists(self.jsonfile):
            force_refresh = True

        if not force_refresh:
            json_ver, json_info = json.load(open(self.jsonfile, 'r'))[:2]
            if json_ver == self.JSONVERSION:
                info = json_info
                if not len(info):
                    force_refresh=True
            elif json_ver > self.JSONVERSION:
                print "ERROR: Json newer than supported version, ignoring json"
                force_refresh=True
            else:
                force_refresh=True

        if DEBUG and not force_refresh:
            print "DEBUG: Forcing refresh of json (debug mode)"
            force_refresh = True

        if force_refresh and os.path.exists(self.FTPROOT):
            curdir = os.getcwd()
            try:
                # Ensures paths are relative to the FTPROOT
                os.chdir(self.FTPROOT)
                top = os.path.join('sources', self.module)
                for root, dirs, files in os.walk(top, topdown=False):
                    for filename in files:
                        r = re_file.match(filename)
                        if r:
                            changed = True

                            fileinfo = r.groupdict()
                            module = fileinfo['module']
                            version = fileinfo['version']
                            format = fileinfo['format']

                            if module != self.module:
                                continue

                            info.setdefault(version, {})[format] = os.path.join(root, filename)
            finally:
                os.chdir(curdir)

        # XXX - maybe remove versions which lack tar.*

        # Group versions by major and minor number
        for version in info:
            majmin = re_version.sub(r'\1', version)
            if majmin not in majmins:
                majmins[majmin] = set()

            majmins[majmin].add(version)

        self.info = info
        self.majmin = majmins
        self.versions = sorted(info, version_cmp)

        if changed:
            # save the new information
            self.write_json()

    def determine_file(self, version, format):
        """Determine file using version and format

        Might return a compressed version of the given format.

        Returns None if format cannot be found"""
        if version not in self.info:
            return None

        formats = [format]
        formats.extend(("%s.%s" % (format, compression) for compression in ("gz", "bz2", "xz")))

        info_formats = self.info[version]
        for f in formats:
            if f in info_formats:
                return os.path.join(self.FTPROOT, info_formats[f])

        return None

    def info_detailed(self, version, format):
        """Provides detailed information about file references by
        version and format.

        Will NOT return a posibly compressed version."""
        if version not in self.info:
            return None

        info = self.info[version].get(format, None)
        if info is None:
            return None

        realpath = os.path.join(self.FTPROOT, info)
        stat = os.stat(realpath)
        return (info, realpath, human_size(stat.st_size), stat)


    def write_json(self): # XXX - should write json
        if self.module is None: return False

        info = self.info
        json.dump((self.JSONVERSION, info), open(self.jsonfile, 'w'))
        if self.GROUPID is not None:
            os.chown(self.jsonfile, -1, self.GROUPID)


class InstallModule(BasicInfo):

    INSTALL_FORMATS = ('tar.gz', 'tar.bz2')

    def __init__(self, file):
        self.file = file

        self.uid = os.getuid()
        self.pw = pwd.getpwuid(self.uid)
        self.who = self.pw.pw_gecos
        self.who = re_who.sub("", self.who)

        self.dirname, self.basename = os.path.split(file)
        self.fileinfo = TarInfo(file)

        if self.fileinfo.module is not None:
            self.module = self.fileinfo.module
            self.majmin = self.fileinfo.majmin
            self.version = self.fileinfo.version
            self.format = self.fileinfo.format

            self.destination = '%s/sources/%s/%s' % (self.FTPROOT, self.fileinfo.module, self.majmin)

        self.moduleinfo = ModuleInfo(self.fileinfo.module)
        self.prevversion = get_latest_version(self.moduleinfo.versions, self.version)



    def confirm_install(self):

        print """      Module: %s
     Version: %s   (previous version: %s)
     Maj.Min: %s
 Destination: %s/""" % (self.module, self.version, self.prevversion or 'N/A', self.majmin, self.destination)

        # Check if the module directory already exists. If not, the module name might contain a typo
        if not os.path.isdir('%s/sources/%s' % (self.FTPROOT, self.module)):
            print """
WARNING: %s is not present in the archive!
         Are you sure that it is new and/or the correct module name?""" % self.module

        print """
Install %s? [Y/n]""" % self.module,
        response = raw_input()

        if response != '' and response[0] != 'y' and response[0] != 'Y':
            print """Module installation cancelled. Please report any problems with this
script to gnome-sysadmin@gnome.org. Thanks."""

            return False

        # install the module
        return True

    def validate(self):
        if self.module is None:
            print 'ERROR: Unrecognized module/version/file format. Make sure to follow a sane naming scheme (MAJOR.MINOR.MICRO)'
            return False

        # Don't allow an existing tarball to be overwritten
        if os.path.exists(os.path.join(self.destination, self.basename)):
            print """ERROR: %s already exists in the archive!""" % self.basename
            if DEBUG:
                print "DEBUG: Continuing anyway in debug mode"
            else:
                return False

        # XXX - verify if tarball is being installed by a maintainer

        # CHECK FOR CONSISTENCY

        errors = self.fileinfo.check()

        tar = tarfile.open(self.file)

        # CHECK 1: Make sure tarball contains a directory called $MODULE-$VERSION
        dir = None
        try:
            dir = tar.getmember('%s-%s' % (self.module, self.version))
        except KeyError:
            pass
        if dir and not dir.isdir():
            dir = None
        if dir is None:
            print 'ERROR: Cannot find expected directory within tarball, aborting!'
            return False

        # Valid file
        return True

    def install(self, unattended=False):
        # Validate the file
        if not self.validate():
            return False


        # Ask user if tarball should be installed
        if not unattended:
            if not self.confirm_install():
                return False


#        for k, v in self.__dict__.iteritems():
#            print k, v

        tmpdir = tempfile.mkdtemp(prefix='install_module')
        try:
            print "Creating new files:"
            # do we have a previous version?
            prev_errors = True # pretend there are error unless proved otherwise
            if self.prevversion:
                prev_file = self.moduleinfo.determine_file(self.prevversion, 'tar')
            else:
                prev_file = None

            if prev_file:
                # validate the previous file
                prev_fileinfo = TarInfo(prev_file)
                sys.stdout.write(" - Checking previous tarball")
                prev_errors = prev_fileinfo.check()
                print ", done"
                if prev_errors:
                    # only diff against the previous version is there are no errors
                    prev_file = None

            for fn in self.fileinfo.file:
                sys.stdout.write(" - %s" % fn)
                with self._make_tmp_file(tmpdir, fn) as f:
                    if prev_file is not None and fn in prev_fileinfo.file:
                        context = 0
                        a = prev_fileinfo.file[fn]
                        b = self.fileinfo.file[fn]
                        for group in difflib.SequenceMatcher(None,a,b).get_grouped_opcodes(context):
                            i1, i2, j1, j2 = group[0][1], group[-1][2], group[0][3], group[-1][4]
                            for tag, i1, i2, j1, j2 in group:
                                if tag == 'replace' or tag == 'insert':
                                    f.writelines(b[j1:j2])
                        print ", done (diff)"
                    elif not prev_errors:
                        # succesfully read previous tarball, didn't find a 'NEWS' / 'ChangeLog'
                        # assume file has been added in this release and no diff is needed
                        f.writelines(self.fileinfo.file[fn])
                        print ", done (new file)"
                    else:
                        print ", ignored (previous tarball is not valid)"


            # Create tarball(s) according to INSTALL_FORMATS
            if self.format in self.INSTALL_FORMATS:
                sys.stdout.write(" - %s" % self.format)
                with open(self.file, 'rb') as f1:
                    with self._make_tmp_file(tmpdir, self.format) as f2:
                        shutil.copyfileobj(f1, f2)
                print ", done"

            formats = [format for format in self.INSTALL_FORMATS if format != self.format]
            if len(formats):
                if len(formats) == 1:
                    sys.stdout.write(" - Compressing %s: " % formats[0])
                else:
                    sys.stdout.write(" - Compressing (at the same time): ")
                f2 = []
                for format in formats:
                    if len(formats) > 1:
                        sys.stdout.write("%s " % format)
                    f = self._make_tmp_file(tmpdir, format, constructor=self.FORMATS[format])
                    f2.append(f)

                BLOCKSIZE=5248000 # 5MB
                f1 = self.FORMATS[self.format](self.file, 'rb')
                while 1:
                    buf = f1.read(BLOCKSIZE)
                    if not buf:
                        break
                    for fdst in f2:
                        fdst.write(buf)
                        sys.stdout.write(".")
                for fdst in f2:
                    fdst.close()
                    f2 = []
                print ", done"


        #        if not os.path.isdir(self.destination):
        #            os.makedirs(self.destination, 042775) # drwxrwsr-x
                # XXX - install the tarball
                # XXX - change ownership of the tarball
                # XXX - refresh version information
                # self.moduleinfo.refresh(force_refresh=True)
        finally:
            # cleanup temporary directory
            if not DEBUG:
                shutil.rmtree(tmpdir)
            else:
                print "DEBUG: Not removing temporary directory: %s" % tmpdir

        self.inform()

    def _make_tmp_file(self, tmpdir, format, constructor=open):
        fn = os.path.join(tmpdir, '%s-%s.%s' % (self.module, self.version, format))
        f = constructor(fn, 'w')
        if self.GROUPID is not None:
            os.chown(fn, -1, self.GROUPID)
        return f

    def inform(self):
        """Inform regarding the new release"""
        print "Doing notifications:"
        if self.version in self.moduleinfo.info:
            sha256sum = {}
            sys.stdout.write(" - Informing ftp-release-list")

            mail = StringIO()

            info = self.moduleinfo.info_detailed(self.version, 'sha256sum')
            if info is not None:
                path, realpath, size, stat = info
                with open(realpath, "r") as f:
                    for line in f.read().splitlines():
                        # XXX - the checksum filed could look differently (binary indicator)
                        if '  ' in line:
                            checksum, file = line.partition('  ')[::2]
                            sha256sum[file] = checksum
                        else:
                            print "WARN: Strange sha256sum line: %s" % line
            else:
                print "WARN: Couldn't determine sha256sum file?!?"

            print >>mail, """       Module: %s
      Version: %s
  Uploaded by: %s
""" % (self.module, self.version, self.who)

            for format in self.FORMATS:
                info = self.moduleinfo.info_detailed(self.version, format)
                if info is not None:
                    path, realpath, size, stat = info
                    dirname, basename = os.path.split(path)
                    print >>mail, "%s/%s" % (self.URLROOT, path)
                    if basename in sha256sum:
                        print >>mail, " sha256sum: %s" % sha256sum[basename]
                    print >>mail, "      size: %s" % size
                    print >>mail, ""

            dump_files = [
                ('news', 'News'),
                ('changes', 'ChangeLog')
            ]

            for format, formatname in dump_files:
                info = self.moduleinfo.info_detailed(self.version, format)
                if info is not None:
                    path, realpath, size, stat = info
                    print >>mail, formatname
                    print >>mail, "-" * len(formatname)
                    print >>mail, ""
                    if stat.st_size > 50000:
                        mail.write("%s/%s" % (self.URLROOT, path))
                    else:
                        with open(realpath, 'r') as f:
                            shutil.copyfileobj(f, mail)
                    print >>mail, ""


            mail.seek(0)
            msg = MIMEText(mail.read(), _charset='utf-8')
            msg['Subject'] = '%s %s' % (self.module, self.version)
            msg['From'] = '"%s" <install-module@master.gnome.org>' % self.who
            msg['To'] = "FTP Releases <ftp-release-list@gnome.org>"
            s = smtplib.SMTP()
            s.connect()
            s.sendmail('install-module@master.gnome.org', ['olav@vitters.nl'], msg.as_string())
            s.quit()

            print ", done"




l = None
def get_module_info(module):
    global l # evil

    if l is None:
        l = ldap.open('ldap-back')
        l.protocol_version = ldap.VERSION3

    filter = ldap.filter.filter_format("(cn=%s)", (module, ))
    data = l.search_s (LDAP_BASE, ldap.SCOPE_SUBTREE, filter, None)

    return data



if __name__ == "__main__":
    (options, args) = parser.parse_args()
    tarballs = [file for file in args if os.path.exists(file)]

    if not len(tarballs):
        parser.print_usage()
        sys.exit(2)

    old_mask = os.umask(0002)
    groupid = grp.getgrnam(GROUP)[2]
    if groupid not in os.getgroups():
        print 'ERROR: Script requires membership of the %s group' % GROUP
        sys.exit(1)

    BasicInfo.GROUPID = groupid

    for file in tarballs:
        handler = InstallModule(file)
        handler.install(unattended=options.unattended)
