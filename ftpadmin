#!/usr/bin/python -u

import sys
import os
import os.path
import grp
import pwd
import ldap
import ldap.filter
import re
import tempfile
import tarfile
import pprint
import difflib
import shutil
import gzip
import bz2
import lzma # pyliblzma
import subprocess
import argparse
from email.mime.text import MIMEText
import json
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO


script_path = os.path.realpath(os.path.abspath(sys.argv[0]))
script_dir = os.path.dirname(script_path) + '/../gitadmin-bin'

sys.path.insert(0, '/home/admin/gitadmin-bin')
sys.path.insert(0, script_dir)


# Lives inside gitadmin-bin
import semi_rdf



DEBUG=True
#DEBUG=False
GROUP='ftpadmin'
LDAP_BASE='ou=modules,dc=gnome,dc=org'
re_file = re.compile(r'^(?P<module>.*?)[_-](?:(?P<oldversion>([0-9]+[\.])*[0-9]+)-)?(?P<version>([0-9]+[\.\-])*[0-9]+)\.(?P<format>(?:tar\.|diff\.)?[a-z][a-z0-9]*)$')
re_version = re.compile(r'^([0-9]+\.[0-9]+).*')
re_who = re.compile(r' <[^>]+>$')

SECTIONS = [
        'sources',
]
DEFAULT_SECTION='sources'


def version_cmp(a, b):
    """Compares two versions

    Returns
      -1 if a < b
      0  if a == b
      1  if a > b

    Important: only supports very specific versions (all numeric, separated by
    dots)"""
    a_nums = a.replace('-', '.0.').split('.')
    b_nums = b.replace('-', '.0.').split('.')
    num_fields = min(len(a_nums), len(b_nums))
    for i in range(0,num_fields):
        if   int(a_nums[i]) < int(b_nums[i]):
            return -1
        elif int(a_nums[i]) > int(b_nums[i]):
            return 1
    return cmp(len(a_nums), len(b_nums))

def get_latest_version(versions, max_version=None):
    """Gets the latest version number

    if max_version is specified, gets the latest version number before
    max_version"""
    latest = None
    for version in versions:
        if ( latest is None or version_cmp(version, latest) > 0 ) \
           and ( max_version is None or version_cmp(version, max_version) < 0 ):
            latest = version
    return latest

def human_size(size):
    suffixes = [("",2**10), ("K",2**20), ("M",2**30), ("G",2**40), ("T",2**50)]

    for suf, lim in suffixes:
        if size < lim:
            break

    sizediv = size/float(lim/2**10)
    if suf == "":
        fmt = "%0.0f%s"
    elif sizediv > 100:
        fmt = "%0.0f%s"
    elif sizediv > 10:
        fmt = "%0.1f%s"
    else:
        fmt = "%0.2f%s"

    return fmt % (size/float(lim/2**10), suf)

class _LZMAProxy(object):
    """Small proxy class that enables external file object
       support for "r:lzma" and "w:lzma" modes. This is actually
       a workaround for a limitation in lzma module's LZMAFile
       class which (unlike gzip.GzipFile) has no support for
       a file object argument.
    """

    blocksize = 16 * 1024

    def __init__(self, fileobj, mode):
        self.fileobj = fileobj
        self.mode = mode
        self.name = getattr(self.fileobj, "name", None)
        self.init()

    def init(self):
#        import lzma
        self.pos = 0
        if self.mode == "r":
            self.lzmaobj = lzma.LZMADecompressor()
            self.fileobj.seek(0)
            self.buf = ""
        else:
            self.lzmaobj = lzma.LZMACompressor()

    def read(self, size):
        b = [self.buf]
        x = len(self.buf)
        while x < size:
            raw = self.fileobj.read(self.blocksize)
            if not raw:
                break
            try:
                data = self.lzmaobj.decompress(raw)
            except EOFError:
                break
            b.append(data)
            x += len(data)
        self.buf = "".join(b)

        buf = self.buf[:size]
        self.buf = self.buf[size:]
        self.pos += len(buf)
        return buf

    def seek(self, pos):
        if pos < self.pos:
            self.init()
        self.read(pos - self.pos)


class XzTarFile(tarfile.TarFile):

    OPEN_METH = tarfile.TarFile.OPEN_METH.copy()
    OPEN_METH["xz"] = "xzopen"

    @classmethod
    def xzopen(cls, name, mode="r", fileobj=None, **kwargs):
        """Open gzip compressed tar archive name for reading or writing.
           Appending is not allowed.
        """
        if len(mode) > 1 or mode not in "rw":
            raise ValueError("mode must be 'r' or 'w'")

        if fileobj is not None:
            fileobj = _LMZAProxy(fileobj, mode)
        else:
            fileobj = lzma.LZMAFile(name, mode)

        try:
            fileobj.read(_LZMAProxy.blocksize)
            fileobj.seek(0)
            t = cls.taropen(name, mode, fileobj, **kwargs)
        except IOError:
            raise tarfile.ReadError("not a xz file")
        except lzma.error:
            raise tarfile.ReadError("not a xz file")
        t._extfileobj = False
        return t

if not hasattr(tarfile.TarFile, 'xvopen'):
    tarfile.open = XzTarFile.open


class BasicInfo(object):
    GROUPID = None

    FTPROOT='/ftp/pub/GNOME'
    URLROOT='http://download.gnome.org'
    BLOCKSIZE=5248000 # 5MB (dot will be printed per block)

    # Note: this defines the formats install-module can read
    #       formats install-module creates is defined in 
    #       ModuleInstall.INSTALL_FORMATS
    #
    # WARNING: When extending this, make sure tarfile.TarFile
    #          actually also supports the new compression!
    #          See e.g. XzTarFile class
    FORMATS = {
        'tar.gz': gzip.GzipFile,
        'tar.bz2': bz2.BZ2File,
        'tar.xz': lzma.LZMAFile
    }

class TarInfo(BasicInfo):

    def __init__(self, path, files=set()):
        self.path = path
        self.file = {}

        self.dirname, self.basename = os.path.split(path)

        tarinfo_files = files.copy()

        r = re_file.match(self.basename)
        if r:
            fileinfo = r.groupdict()

            self.module = fileinfo['module']
            self.version = fileinfo['version']
            self.format = fileinfo['format']
            self.majmin = re_version.sub(r'\1', fileinfo['version'])

            tarinfo_files.add('%s-%s/ChangeLog' % (self.module, self.version))
            tarinfo_files.add('%s-%s/NEWS' % (self.module, self.version))
        else:
            self.module = None
            self.version = None
            self.format = None
            self.majmin = None

        self.files = tarinfo_files

    def check(self, progress=False):
        """Check tarball consistency"""
        errors = {}
        files = self.files

        t = None
        try:
            t = tarfile.open(self.path, 'r', errors=2)

            size_files = 0
            file_count = 0
            uniq_dir = None
            dots_shown = 0
            for info in t:
                file_count += 1
                size_files += info.size

                if info.name in files:
                    self.file[os.path.basename(info.name)] = t.extractfile(info).readlines()

                if file_count == 1 and info.isdir():
                    uniq_dir = "%s/" % info.name
                elif uniq_dir is not None and not info.name.startswith(uniq_dir):
                    uniq_dir = None
                if progress:
                    dots_to_show = t.offset / self.BLOCKSIZE
                    if dots_to_show > dots_shown:
                        sys.stdout.write("." * (dots_to_show - dots_shown))
                        dots_shown = dots_to_show

            # Now determine the current position in the tar file
            tar_end_of_data_pos = t.fileobj.tell()
            # as well as the last position in the tar file
            # Note: doing a read as seeking is often not supported :-(
            t.fileobj.read()
            tar_end_of_file_pos = t.fileobj.tell()


            test_uniq_dir = '%s-%s/' % (self.module, self.version)
            if uniq_dir is None:
                errors['NO_UNIQ_DIR'] = 'Files should all be in one directory (%s)' % test_uniq_dir
            elif uniq_dir != test_uniq_dir:
                errors['UNIQ_DIR'] = 'Files not in the correct directory (expected %s, found %s)' % (test_uniq_dir, uniq_dir)

            test_eof_data = (tar_end_of_file_pos - tar_end_of_data_pos)
            MAX_EXTRA_DATA=10240
            if test_eof_data > MAX_EXTRA_DATA:
                errors['EXTRA_DATA'] = 'Tarball has too much extra data (expected max %s, found %s)' % (human_size(MAX_EXTRA_DATA), human_size(test_eof_data))

            if not isinstance(t.fileobj, self.FORMATS.get(self.format, "")):
                errors['WRONG_EXT'] = 'Compression used is different than what extension suggests'

            self.size_files = size_files
            self.file_count = file_count
            self.tar_end_of_data_pos = tar_end_of_data_pos
            self.tar_end_of_file_pos = tar_end_of_file_pos
            self.uniq_dir = uniq_dir
        except tarfile.ReadError:
            errors['INVALID_FILE'] = 'Tarball cannot be read'
        finally:
            if t:
                t.close()

        # XXX  - actually validate the tarball and return errors
        return errors


class ModuleInfo(BasicInfo):
    JSONVERSION = 2

    def __init__(self, modulename, section=DEFAULT_SECTION):
        self.module = modulename
        self.section = section

        # Determine maintainers
        self.maintainers = []
        if self.module:
            data = get_module_info(self.module)
            if len(data):
                self.maintainers = data[0][1]['maintainerUid']

            self.jsonfile = os.path.join(self.FTPROOT, self.section, self.module, '%s.json' % self.module)

        self.read_json()

    def refresh(self):
        if self.module is None: return False

        self.read_json(force_refresh=True)

    def read_json(self, force_refresh=False):
        if self.module is None:
            self.info = {}
            self.majmin = {}
            self.versions = []

            return False

        info = {}
        majmins = {}
        ignored = {}
        changed = False

        if not os.path.exists(self.jsonfile):
            force_refresh = True

        if not force_refresh:
            j = json.load(open(self.jsonfile, 'rb'))
            json_ver = j[0]
            if json_ver == self.JSONVERSION:
                json_ver, info, json_versions, ignored = j
                if not len(info):
                    force_refresh=True
            elif json_ver > self.JSONVERSION:
                print "ERROR: Json newer than supported version, ignoring json"
                force_refresh=True
            else:
                force_refresh=True

        if force_refresh and os.path.exists(self.FTPROOT):
            curdir = os.getcwd()
            try:
                # Ensures paths are relative to the FTPROOT
                os.chdir(self.FTPROOT)
                top = os.path.join(self.section, self.module)
                for root, dirs, files in os.walk(top, topdown=False):
                    for filename in files:
                        r = re_file.match(filename)
                        if r:
                            changed = True

                            fileinfo = r.groupdict()
                            module = fileinfo['module']
                            version = fileinfo['version']
                            format = fileinfo['format']

                            if module == self.module:
                                info.setdefault(version, {})[format] = os.path.join(root, filename)
                                continue

                        # If we arrive here, it means we ignored the file for some reason
                        if root not in ignored:
                            ignored[root] = []
                        ignored[root].append(filename)
            finally:
                os.chdir(curdir)

        # XXX - maybe remove versions which lack tar.*

        # Group versions by major and minor number
        for version in info:
            majmin = re_version.sub(r'\1', version)
            if majmin not in majmins:
                majmins[majmin] = set()

            majmins[majmin].add(version)

        self.info = info
        self.majmin = majmins
        self.versions = sorted(info, version_cmp)
        self.ignored = ignored

#        if DEBUG:
#            pprint.pprint(ignored)

        if changed:
            # save the new information
            self.write_json()

    def determine_file(self, version, format):
        """Determine file using version and format

        Might return a compressed version of the given format.

        Returns None if format cannot be found"""
        if version not in self.info:
            return None

        formats = [format]
        formats.extend(("%s.%s" % (format, compression) for compression in ("gz", "bz2", "xz")))

        info_formats = self.info[version]
        for f in formats:
            if f in info_formats:
                return os.path.join(self.FTPROOT, info_formats[f])

        return None

    def info_detailed(self, version, format):
        """Provides detailed information about file references by
        version and format.

        Will NOT return a posibly compressed version."""
        if version not in self.info:
            return None

        info = self.info[version].get(format, None)
        if info is None:
            return None

        realpath = os.path.join(self.FTPROOT, info)
        stat = os.stat(realpath)
        return (info, realpath, human_size(stat.st_size), stat)


    def write_json(self):
        if self.module is None: return False

        info = self.info
        json.dump((self.JSONVERSION, info, self.versions, self.ignored), open(self.jsonfile, 'w'))
        if self.GROUPID is not None:
            os.chown(self.jsonfile, -1, self.GROUPID)


class InstallModule(BasicInfo):

    INSTALL_FORMATS = ('tar.gz', 'tar.bz2')

    def __init__(self, file, section=DEFAULT_SECTION):
        self.file = file

        self.uid = os.getuid()
        self.pw = pwd.getpwuid(self.uid)
        self.who = self.pw.pw_gecos
        self.who = re_who.sub("", self.who)
        if self.who == "":
            self.who = self.pw.pw_name

        self.section = section
        self.dirname, self.basename = os.path.split(file)
        self.fileinfo = TarInfo(file)

        if self.fileinfo.module is not None:
            self.module = self.fileinfo.module
            self.majmin = self.fileinfo.majmin
            self.version = self.fileinfo.version
            self.format = self.fileinfo.format

            self.destination = '%s/%s/%s/%s' % (self.FTPROOT, self.section, self.fileinfo.module, self.majmin)

        self.moduleinfo = ModuleInfo(self.fileinfo.module, section=self.section)
        self.prevversion = get_latest_version(self.moduleinfo.versions, self.version)



    def confirm_install(self):

        print """      Module: %s
     Version: %s   (previous version: %s)
 Destination: %s/""" % (self.module, self.version, self.prevversion or 'N/A', self.destination)

        # Check if the module directory already exists. If not, the module name might contain a typo
        if not os.path.isdir('%s/%s/%s' % (self.FTPROOT, self.section, self.module)):
            print """
WARNING: %s is not present in the archive!
         Are you sure that it is new and/or the correct module name?""" % self.module

        print """
Install %s? [Y/n]""" % self.module,
        response = raw_input()

        if response != '' and response[0] != 'y' and response[0] != 'Y':
            print """Module installation cancelled. Please report any problems with this
script to gnome-sysadmin@gnome.org. Thanks."""

            return False

        # install the module
        return True

    def validate(self):
        if self.module is None:
            print 'ERROR: Unrecognized module/version/file format. Make sure to follow a sane naming scheme (MAJOR.MINOR.MICRO)'
            return False

        # Don't allow an existing tarball to be overwritten
        if os.path.exists(os.path.join(self.destination, self.basename)):
            print """ERROR: %s already exists in the archive!""" % self.basename
            if DEBUG:
                print "DEBUG: Continuing anyway in debug mode"
            else:
                return False

        # XXX - verify if tarball is being installed by a maintainer

        # CHECK FOR CONSISTENCY
        sys.stdout.write("Checking consistency %s: " % self.file)
        errors = self.fileinfo.check(progress=True)
        if not errors:
            print ", done"
        else:
            print ", failed"
            for k, v in errors.iteritems():
                print "ERROR: %s" % v

        # True if there are no errors
        return len(errors) == 0

    def install(self, unattended=False):
        # Validate the file
        if not self.validate():
            return False


        # Ask user if tarball should be installed
        if not unattended:
            if not self.confirm_install():
                return False


#        for k, v in self.__dict__.iteritems():
#            print k, v

        tmpdir = tempfile.mkdtemp(prefix='install_module')
        try:
            print "Creating new files:"
            created_files = []
            # do we have a previous version?
            prev_errors = True # pretend there are error unless proved otherwise
            if self.prevversion:
                prev_file = self.moduleinfo.determine_file(self.prevversion, 'tar')
            else:
                prev_file = None

            if prev_file:
                # validate the previous file
                prev_fileinfo = TarInfo(prev_file)
                sys.stdout.write(" - Checking previous tarball: ")
                prev_errors = prev_fileinfo.check(progress=True)
                if not prev_errors:
                    print ", done"
                else:
                    print ", failed (ignoring previous tarball!)"
                    # only diff against the previous version is there are no errors
                    prev_file = None

            for fn in self.fileinfo.file:
                sys.stdout.write(" - %s" % fn)
                with self._make_tmp_file(tmpdir, fn) as f:
                    if prev_file is not None and fn in prev_fileinfo.file:
                        context = 0
                        a = prev_fileinfo.file[fn]
                        b = self.fileinfo.file[fn]
                        break_for = False
                        lines = 0
                        for group in difflib.SequenceMatcher(None,a,b).get_grouped_opcodes(context):
                            i1, i2, j1, j2 = group[0][1], group[-1][2], group[0][3], group[-1][4]
                            for tag, i1, i2, j1, j2 in group:
                                if tag == 'replace' or tag == 'insert':
                                    lines += j2 - j1
                                    f.writelines(b[j1:j2])
                                    break_for = True
                            if break_for:
                                break
                        if lines > 2:
                            created_files.append(f.name)
                            print ", done (diff, %s lines)" % lines
                        else:
                            print ", ignored (no change)"
                            os.remove(f.name)
                    elif not prev_errors:
                        # succesfully read previous tarball, didn't find a 'NEWS' / 'ChangeLog'
                        # assume file has been added in this release and no diff is needed
                        f.writelines(self.fileinfo.file[fn])
                        created_files.append(f.name)
                        print ", done (new file)"
                    else:
                        print ", ignored (previous tarball is not valid)"


            # Create tarball(s) according to INSTALL_FORMATS
            if self.format in self.INSTALL_FORMATS:
                sys.stdout.write(" - Copying %s" % self.format)
                with open(self.file, 'rb') as f1:
                    with self._make_tmp_file(tmpdir, self.format) as f2:
                        created_files.append(f2.name)
                        shutil.copyfileobj(f1, f2)
                print ", done"

            formats = [format for format in self.INSTALL_FORMATS if format != self.format]
            if len(formats):
                if len(formats) == 1:
                    sys.stdout.write(" - Creating %s from %s: " % (formats[0], self.format))
                else:
                    sys.stdout.write(" - Creating tarballs from %s: " % self.format)
                f2 = []
                for format in formats:
                    if len(formats) > 1:
                        sys.stdout.write("%s " % format)
                    f = self._make_tmp_file(tmpdir, format, constructor=self.FORMATS[format])
                    created_files.append(f.name)
                    f2.append(f)

                f1 = self.FORMATS[self.format](self.file, 'rb')
                while 1:
                    buf = f1.read(self.BLOCKSIZE)
                    if not buf:
                        break
                    for fdst in f2:
                        fdst.write(buf)
                        sys.stdout.write(".")
                for fdst in f2:
                    fdst.close()
                    f2 = []
                print ", done"



            sys.stdout.write(" - Creating sha256sum")
            with self._make_tmp_file(tmpdir, 'sha256sum') as f:
                cmd = ['sha256sum', '--']
                cmd.extend([os.path.basename(fn) for fn in created_files if os.path.isfile(fn)])
                subprocess.call(cmd, stdout=f, cwd=tmpdir)
            print ", done"

        #        if not os.path.isdir(self.destination):
        #            os.makedirs(self.destination, 042775) # drwxrwsr-x
                # XXX - install the tarball
                # XXX - change ownership of the tarball
        finally:
            # cleanup temporary directory
            if not DEBUG:
                shutil.rmtree(tmpdir)
            else:
                print "DEBUG: Not removing temporary directory: %s" % tmpdir

        sys.stdout.write(" - Updating known versions")
        self.moduleinfo.refresh()
        print ", done"

        self.inform()
        return True

    def _make_tmp_file(self, tmpdir, format, constructor=open):
        fn = os.path.join(tmpdir, '%s-%s.%s' % (self.module, self.version, format))
        f = constructor(fn, 'w')
        if self.GROUPID is not None:
            os.chown(fn, -1, self.GROUPID)
        return f

    def inform(self):
        """Inform regarding the new release"""
        print "Doing notifications:"
        if self.version not in self.moduleinfo.info:
            return False

        sha256sum = {}
        sys.stdout.write(" - Informing ftp-release-list")

        mail = StringIO()

        info = self.moduleinfo.info_detailed(self.version, 'sha256sum')
        if info is not None:
            path, realpath, size, stat = info
            with open(realpath, "r") as f:
                for line in f.read().splitlines():
                    # XXX - the checksum filed could look differently (binary indicator)
                    if '  ' in line:
                        checksum, file = line.partition('  ')[::2]
                        sha256sum[file] = checksum
                    else:
                        print "WARN: Strange sha256sum line: %s" % line
        else:
            print "WARN: Couldn't determine sha256sum file?!?"

        print >>mail, """       Module: %s
      Version: %s
  Uploaded by: %s
""" % (self.module, self.version, self.who)

        for format in self.FORMATS:
            info = self.moduleinfo.info_detailed(self.version, format)
            if info is not None:
                path, realpath, size, stat = info
                dirname, basename = os.path.split(path)
                print >>mail, "%s/%s" % (self.URLROOT, path)
                if basename in sha256sum:
                    print >>mail, " sha256sum: %s" % sha256sum[basename]
                print >>mail, "      size: %s" % size
                print >>mail, ""

        dump_files = [
            ('news', 'News'),
            ('changes', 'ChangeLog')
        ]
        show_contents = True
        for format, formatname in dump_files:
            info = self.moduleinfo.info_detailed(self.version, format)
            if info is not None:
                path, realpath, size, stat = info
                if show_contents and stat.st_size < 50000:
                    with open(realpath, 'r') as f:
                        line = f.readline()
                        if not self.version in line:
                            print >>mail, formatname
                            print >>mail, "-" * len(formatname)
                            print >>mail, ""
                        mail.write(line)
                        shutil.copyfileobj(f, mail)
                else:
                    print >>mail, formatname
                    print >>mail, "-" * len(formatname)
                    mail.write("%s/%s  (%s)" % (self.URLROOT, path, size))
                print >>mail, ""
                # Only show the contents of the first found file, URLs for the rest
                show_contents = False


        mail.seek(0)
        subject = '%s %s' % (self.module, self.version)
        to = "FTP Releases <ftp-release-list@gnome.org>"
        retcode = self._send_email(mail.read(), subject, to, ['olav@vitters.nl'])
        print ", done"

        sys.stdout.write(" - Triggering GNOME library update")
        subject = 'GNOME_GIT library-web'
        to = "gnomeweb@www.gnome.org"
        retcode = self._send_email("forced", subject, to, ['olav@vitters.nl'])
        print ", done"

        sys.stdout.write(" - Adding new version to GNOME Bugzilla")
        cmd = ['/usr/bin/curl', '-q', '-L', 'https://bugzilla.gnome.org/add-version.cgi?%s|%s' % (self.module, self.version)]
        self._call_cmd(cmd)

        sys.stdout.write(" - Triggering ftp.gnome.org update")
        syncscript = ['/usr/local/bin/signal-ftp-sync']
        if self._call_cmd(cmd):
            print ""
            print "Your tarball will appear in the following location on ftp.gnome.org:"
            print ""
            print "  %s" % "/".join((self.URLROOT, self.section, self.module, self.majmin, ""))
            print ""
            print "It is important to retain the trailing slash for compatibility with"
            print "broken http clients, and to use http as it is less taxing on the server."
            info = self.moduleinfo.info_detailed(self.version, 'sha256sum')
            if info is not None:
                print ""
                path, realpath, size, stat = info
                with open(realpath, "r") as f:
                    shutil.copyfileobj(f, sys.stdout)


    def _call_cmd(self, cmd):
        """Calls a certain command and shows progress

        Note: returns True even if exit code is not zero."""

        if not os.path.isfile(cmd[0]):
            print ", FAILED (cannot find %s)" % cmd[0]
            print "PLEASE INFORM gnome-sysadmin@gnome.org ASAP!!!"

            return False

        if DEBUG:
            print ", ignored (debug mode)"
            return True

        retcode = subprocess.call(cmd)
        if retcode == 0:
            print ", done"
        else:
            print "FAILED (exit code %s)" % retcode

        return True


    def _send_email(self, contents, subject, to, smtp_to):
        """Send an email"""
        msg = MIMEText(contents, _charset='utf-8')
        msg['Subject'] = subject
        msg['From'] = '"%s" <install-module@master.gnome.org>' % self.who
        msg['To'] = to

        if DEBUG:
            smtp_to = ['olav@vitters.nl']

        # Call sendmail program directly so it doesn't matter if the service is running
        cmd = ['/usr/sbin/sendmail', '-oi', '-f', 'noreply@gnome.org', '--']
        cmd.extend(smtp_to)
        p = subprocess.Popen(cmd, stdin=subprocess.PIPE)
        p.stdin.write(msg.as_string())
        p.stdin.flush()
        p.stdin.close()
        return p.wait()





l = None
def get_module_info(module):
    global l # evil

    if l is None:
        l = ldap.open('ldap-back')
        l.protocol_version = ldap.VERSION3

    filter = ldap.filter.filter_format("(cn=%s)", (module, ))
    data = l.search_s (LDAP_BASE, ldap.SCOPE_SUBTREE, filter, None)

    return data

def cmd_install(options, parser):
    tarballs = [file for file in options.tarball if os.path.exists(file)]

    if not len(tarballs):
        parser.print_help()
        sys.exit(2)

    for file in tarballs:
        sys.stdout.write("Checking for info about %s" % file)
        handler = InstallModule(file)
        print ", done"
        handler.install(unattended=options.unattended)

def cmd_show_info(options, parser):
    import glob
    import datetime

    modules = [os.path.basename(path) for path in glob.glob(os.path.join(BasicInfo.FTPROOT, options.section, '*')) if os.path.isdir(path)]
    for module in modules:
        moduleinfo = ModuleInfo(module, options.section)
        if len(moduleinfo.versions):
            version= moduleinfo.versions[-1]
        else:
            version = ""
        changed = ""
        if version:
            info = moduleinfo.info_detailed(version, 'tar.gz')
            if info:
                path, realpath, size, stat = info
                changed = datetime.date.fromtimestamp(stat.st_ctime).isoformat()

        print "\t".join((module, version, changed, ", ".join(moduleinfo.maintainers)))

def cmd_sudo(options, parser):
    print "ERROR: Not yet implemented!"
    sys.exit(2)

def cmd_gnome_news(options, parser):
    print ""

def cmd_validate_tarballs(options, parser):
    print options.module, options.section
    moduleinfo = ModuleInfo(options.module, section=options.section)
    for version in moduleinfo.versions:
        print "Version: %s" % version
        for format in BasicInfo.FORMATS:
            info = moduleinfo.info_detailed(version, format)
            if info is not None:
                path, realpath, size, stat = info

                prev_fileinfo = TarInfo(realpath)
                sys.stdout.write(" - Checking %s: " % format)
                errors = prev_fileinfo.check(progress=True)
                if errors:
                    print ", FAILED"
                    for k, v in errors.iteritems():
                        print "ERROR: %s" % v
                else:
                    print ", success"

def main():
    try:
        groupid = grp.getgrnam(GROUP)[2]
    except KeyError:
        print 'FATAL: Group %s does NOT exist!' % GROUP
        print 'FATAL: Please inform gnome-sysadmin@gnome.org!'
        sys.exit(1)

    if groupid is None or (os.getgid() != groupid and groupid not in os.getgroups()):
        print 'FATAL: Script requires membership of the %s group' % GROUP
        sys.exit(1)

    BasicInfo.GROUPID = groupid

    usage = "usage: %prog [options] TARBALL [TARBALL ...]"
    description = """Install new tarball(s) to GNOME FTP master and make it available on the mirrors."""

    epilog="""Report bugs to gnome-sysadmin@gnome.org"""
    parser = argparse.ArgumentParser(description=description,epilog=epilog)


    # SUBPARSERS
    subparsers = parser.add_subparsers(title='subcommands')
    #   install
    parser_install = subparsers.add_parser('install', help='install a module to %s' % BasicInfo.URLROOT)
    parser_install.add_argument("-f", "--force", action="store_true", dest="clobber",
                              help="Overwrite the original tarball")
    parser_install.add_argument("-u", "--unattended", action="store_true",
            help="do not prompt for confirmation.\n\nNOTE: An unattended install " +
            "will not provide any extra information to help you avoid an invalid " +
            "(and potentially messy) installation. It is recommended that you do not " +
            "use this unless you are *very* sure.")
    parser_install.add_argument('tarball', nargs='+', help='Tarball(s) to install')
    parser_install.add_argument("-s", "--section", choices=SECTIONS,
                              help="Section to install the file to")
    parser_install.set_defaults(
        func=cmd_install, clobber=False, unattended=False, section=DEFAULT_SECTION
    )
    #   show-info
    parser_show_info = subparsers.add_parser('show-info', help='show module information')
    parser_show_info.set_defaults(func=cmd_show_info)
    #   sudo
    parser_sudo = subparsers.add_parser('sudo', help='install tarballs uploaded using rsync')
    parser_sudo.set_defaults(func=cmd_sudo)
    #   gnome-news
    parser_gnome_news = subparsers.add_parser('gnome-news', help='show news between two GNOME versions')
    parser_gnome_news.add_argument('suite', metavar='SUITE', help='Suite to check (e.g. core or apps)')
    parser_gnome_news.add_argument('oldversion', metavar='OLDVERSION', help='Previous GNOME version')
    parser_gnome_news.add_argument('newversion', metavar='NEWVERSION', help='New GNOME version')
    parser_gnome_news.set_defaults(func=cmd_gnome_news)
    #   validate-tarballs
    parser_validate_tarballs = subparsers.add_parser('validate-tarballs', help='validate all tarballs for a given module')
    parser_validate_tarballs.add_argument("-s", "--section", choices=SECTIONS,
                              help="Section to install the file to")
    parser_validate_tarballs.add_argument('module', help='Module to validate')
    parser_validate_tarballs.set_defaults(func=cmd_validate_tarballs, section=DEFAULT_SECTION)

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(2)

    options = parser.parse_args()

    old_mask = os.umask(0002)

    if DEBUG:
        print "WARNING: Running in DEBUG MODE!"

    options.func(options, parser)


if __name__ == "__main__":
    main()
