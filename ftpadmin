#!/usr/bin/python -u

import sys
import os
import os.path
import grp
import pwd
import ldap
import ldap.filter
import re
import tempfile
import tarfile
import pprint
import difflib
import shutil
import gzip
import bz2
import lzma # pyliblzma
import subprocess
import argparse
import errno
from email.mime.text import MIMEText
import json
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO


script_path = os.path.realpath(os.path.abspath(sys.argv[0]))
script_dir = os.path.dirname(script_path) + '/../gitadmin-bin'

sys.path.insert(0, '/home/admin/gitadmin-bin')
sys.path.insert(0, script_dir)

# Lives inside gitadmin-bin
import semi_rdf

DEBUG=True
# Protection, only ovitters should be using debug mode:
if os.environ['USER'] != 'ovitters':
    DEBUG=False

GROUP='ftpadmin'
LDAP_BASE='ou=modules,dc=gnome,dc=org'
re_file = re.compile(r'^(?P<module>.*?)[_-](?:(?P<oldversion>([0-9]+[\.])*[0-9]+)-)?(?P<version>([0-9]+[\.\-])*[0-9]+)\.(?P<format>(?:tar\.|diff\.)?[a-z][a-z0-9]*)$')
re_version = re.compile(r'^([0-9]+\.[0-9]+).*')
re_who = re.compile(r' <[^>]+>$')

SECTIONS = [
        'sources',
]
DEFAULT_SECTION='sources'
SUITES = [
        'core',
        'apps',
        'platform',
        'desktop',
        'bindings',
        'admin',
        'devtools',
        'mobile',
]
DEFAULT_SUITE=SUITES[0]

def version_cmp(a, b):
    """Compares two versions

    Returns
      -1 if a < b
      0  if a == b
      1  if a > b

    Important: only supports very specific versions (all numeric, separated by
    dots)"""
    a_nums = a.replace('-', '.0.').split('.')
    b_nums = b.replace('-', '.0.').split('.')
    num_fields = min(len(a_nums), len(b_nums))
    for i in range(0,num_fields):
        if   int(a_nums[i]) < int(b_nums[i]):
            return -1
        elif int(a_nums[i]) > int(b_nums[i]):
            return 1
    return cmp(len(a_nums), len(b_nums))

def get_latest_version(versions, max_version=None):
    """Gets the latest version number

    if max_version is specified, gets the latest version number before
    max_version"""
    latest = None
    for version in versions:
        if ( latest is None or version_cmp(version, latest) > 0 ) \
           and ( max_version is None or version_cmp(version, max_version) < 0 ):
            latest = version
    return latest

def human_size(size):
    suffixes = [("",2**10), ("K",2**20), ("M",2**30), ("G",2**40), ("T",2**50)]

    for suf, lim in suffixes:
        if size < lim:
            break

    sizediv = size/float(lim/2**10)
    if suf == "":
        fmt = "%0.0f%s"
    elif sizediv > 100:
        fmt = "%0.0f%s"
    elif sizediv > 10:
        fmt = "%0.1f%s"
    else:
        fmt = "%0.2f%s"

    return fmt % (size/float(lim/2**10), suf)

def makedirs_chown(name, mode=0777, uid=-1, gid=-1):
    """Lake os.makedirs, but also does a chown
    """
    head, tail = os.path.split(name)
    if not tail:
        head, tail = os.path.split(head)
    if head and tail and not os.path.exists(head):
        try:
            makedirs_chown(head, mode, uid, gid)
        except OSError, e:
            # be happy if someone already created the path
            if e.errno != errno.EEXIST:
                raise
        if tail == os.path.curdir:           # xxx/newdir/. exists if xxx/newdir exists
            return
    os.mkdir(name, mode)
    os.chown(name, uid, gid)

class _LZMAProxy(object):
    """Small proxy class that enables external file object
       support for "r:lzma" and "w:lzma" modes. This is actually
       a workaround for a limitation in lzma module's LZMAFile
       class which (unlike gzip.GzipFile) has no support for
       a file object argument.
    """

    blocksize = 16 * 1024

    def __init__(self, fileobj, mode):
        self.fileobj = fileobj
        self.mode = mode
        self.name = getattr(self.fileobj, "name", None)
        self.init()

    def init(self):
#        import lzma
        self.pos = 0
        if self.mode == "r":
            self.lzmaobj = lzma.LZMADecompressor()
            self.fileobj.seek(0)
            self.buf = ""
        else:
            self.lzmaobj = lzma.LZMACompressor()

    def read(self, size):
        b = [self.buf]
        x = len(self.buf)
        while x < size:
            raw = self.fileobj.read(self.blocksize)
            if not raw:
                break
            try:
                data = self.lzmaobj.decompress(raw)
            except EOFError:
                break
            b.append(data)
            x += len(data)
        self.buf = "".join(b)

        buf = self.buf[:size]
        self.buf = self.buf[size:]
        self.pos += len(buf)
        return buf

    def seek(self, pos):
        if pos < self.pos:
            self.init()
        self.read(pos - self.pos)


class XzTarFile(tarfile.TarFile):

    OPEN_METH = tarfile.TarFile.OPEN_METH.copy()
    OPEN_METH["xz"] = "xzopen"

    @classmethod
    def xzopen(cls, name, mode="r", fileobj=None, **kwargs):
        """Open gzip compressed tar archive name for reading or writing.
           Appending is not allowed.
        """
        if len(mode) > 1 or mode not in "rw":
            raise ValueError("mode must be 'r' or 'w'")

        if fileobj is not None:
            fileobj = _LMZAProxy(fileobj, mode)
        else:
            fileobj = lzma.LZMAFile(name, mode)

        try:
            fileobj.read(_LZMAProxy.blocksize)
            fileobj.seek(0)
            t = cls.taropen(name, mode, fileobj, **kwargs)
        except IOError:
            raise tarfile.ReadError("not a xz file")
        except lzma.error:
            raise tarfile.ReadError("not a xz file")
        t._extfileobj = False
        return t

if not hasattr(tarfile.TarFile, 'xvopen'):
    tarfile.open = XzTarFile.open


class BasicInfo(object):
    GROUPID = None

    FTPROOT='/ftp/pub/GNOME'
    URLROOT='http://download.gnome.org'
    BLOCKSIZE=2*1024*1024 # (dot will be printed per block for progress indication)

    # Note: this defines the formats install-module can read
    #       formats install-module creates are defined in
    #       ModuleInstall.INSTALL_FORMATS
    #
    # WARNING: When extending this, make sure tarfile.TarFile
    #          actually also supports the new compression!
    #          See e.g. XzTarFile class
    FORMATS = {
        'tar.gz': gzip.GzipFile,
        'tar.bz2': bz2.BZ2File,
        'tar.xz': lzma.LZMAFile
    }

class TarInfo(BasicInfo):

    def __init__(self, path, files=set()):
        self.path = path
        self.file = {}

        self.dirname, self.basename = os.path.split(path)

        tarinfo_files = files.copy()

        r = re_file.match(self.basename)
        if r:
            fileinfo = r.groupdict()

            self.module = fileinfo['module']
            self.version = fileinfo['version']
            self.format = fileinfo['format']
            self.majmin = re_version.sub(r'\1', fileinfo['version'])

            tarinfo_files.add('%s-%s/ChangeLog' % (self.module, self.version))
            tarinfo_files.add('%s-%s/NEWS' % (self.module, self.version))
        else:
            self.module = None
            self.version = None
            self.format = None
            self.majmin = None

        self.files = tarinfo_files

    def check(self, progress=False):
        """Check tarball consistency"""
        if hasattr(self, '_errors'):
            return self._errors

        errors = {}
        files = self.files

        t = None
        try:
            t = tarfile.open(self.path, 'r')

            size_files = 0
            file_count = 0
            uniq_dir = None
            dots_shown = 0
            for info in t:
                file_count += 1
                size_files += info.size

                if info.name in files:
                    self.file[os.path.basename(info.name)] = t.extractfile(info).readlines()

                if file_count == 1 and info.isdir():
                    uniq_dir = "%s/" % info.name
                elif uniq_dir is not None and not info.name.startswith(uniq_dir):
                    uniq_dir = None
                if progress:
                    dots_to_show = t.offset / self.BLOCKSIZE
                    if dots_to_show > dots_shown:
                        sys.stdout.write("." * (dots_to_show - dots_shown))
                        dots_shown = dots_to_show

            # Now determine the current position in the tar file
            tar_end_of_data_pos = t.fileobj.tell()
            # as well as the last position in the tar file
            # Note: doing a read as seeking is often not supported :-(
            t.fileobj.read()
            tar_end_of_file_pos = t.fileobj.tell()


            test_uniq_dir = '%s-%s/' % (self.module, self.version)
            if uniq_dir is None:
                errors['NO_UNIQ_DIR'] = 'Files should all be in one directory (%s)' % test_uniq_dir
            elif uniq_dir != test_uniq_dir:
                errors['UNIQ_DIR'] = 'Files not in the correct directory (expected %s, found %s)' % (test_uniq_dir, uniq_dir)

            test_eof_data = (tar_end_of_file_pos - tar_end_of_data_pos)
            MAX_EXTRA_DATA=10240
            if test_eof_data > MAX_EXTRA_DATA:
                errors['EXTRA_DATA'] = 'Tarball has too much extra data (expected max %s, found %s)' % (human_size(MAX_EXTRA_DATA), human_size(test_eof_data))

            if not isinstance(t.fileobj, self.FORMATS.get(self.format, "")):
                errors['WRONG_EXT'] = 'Compression used is different than what extension suggests'

            self.size_files = size_files
            self.file_count = file_count
            self.tar_end_of_data_pos = tar_end_of_data_pos
            self.tar_end_of_file_pos = tar_end_of_file_pos
            self.uniq_dir = uniq_dir
        except tarfile.ReadError:
            errors['INVALID_FILE'] = 'Tarball cannot be read'
        finally:
            if t:
                t.close()

        self._errors = errors
        return self._errors

    def diff(self, files, prev_tarinfo, constructor, progress=False):
        diffs = {}
        prev_errors = False

        # Only diff if the current tarbal has at least one file to diff
        found_files = len([fn for fn in files if fn in self.file])
        if not found_files:
            return diffs

        if prev_tarinfo:
            if progress:
                sys.stdout.write(" - Checking previous tarball: ")
            prev_errors = prev_tarinfo.check(progress)
            if not prev_errors:
                if progress:
                    print ", done"
            else:
                if progress:
                    print ", failed (ignoring previous tarball!)"

        for fn in files:
            if fn not in self.file:
                continue

            if progress:
                sys.stdout.write(" - %s" % fn)

            f = constructor(fn)
            if prev_tarinfo is not None and fn in prev_tarinfo.file:
                context = 0
                a = prev_tarinfo.file[fn]
                b = self.file[fn]
                break_for = False
                lines = 0
                for group in difflib.SequenceMatcher(None,a,b).get_grouped_opcodes(context):
                    i1, i2, j1, j2 = group[0][1], group[-1][2], group[0][3], group[-1][4]
                    for tag, i1, i2, j1, j2 in group:
                        if tag == 'replace' or tag == 'insert':
                            lines += j2 - j1
                            f.writelines(b[j1:j2])
                            break_for = True
                    if break_for:
                        break
                if lines > 2:
                    diffs[fn] = f
                    if progress:
                        print ", done (diff, %s lines)" % lines
                else:
                    if progress:
                        print ", ignored (no change)"
                    if hasattr(f, 'name'):
                        os.remove(f.name)
            elif not prev_errors:
                # succesfully read previous tarball, didn't find a 'NEWS' / 'ChangeLog'
                # assume file has been added in this release and no diff is needed
                f.writelines(self.file[fn])
                diffs[fn] = f
                print ", done (new file)"
            else:
                print ", ignored (previous tarball is not valid)"

        return diffs

class DirectoryInfo(BasicInfo):
    JSONVERSION = 4

    def __init__(self, relpath, limit_module=None):
        self.relpath = relpath
        self.module = limit_module
        self.jsonfile = os.path.join(self.FTPROOT, relpath, 'info.json')

        self.read_json()

    def refresh(self):
        self.read_json(force_refresh=True)

    def read_json(self, force_refresh=False):
        info = {}
        ignored = {}
        changed = False

        if not os.path.exists(self.jsonfile):
            force_refresh = True

        if not force_refresh:
            j = json.load(open(self.jsonfile, 'rb'))
            json_ver = j[0]
            if json_ver == self.JSONVERSION:
                json_ver, info, json_versions, ignored = j
                if not len(info):
                    force_refresh=True
            elif json_ver > self.JSONVERSION:
                print >>sys.stderr, "ERROR: Json newer than supported version, ignoring json"
                force_refresh=True
            else:
                force_refresh=True

        absdir = os.path.join(self.FTPROOT, self.relpath)
        if force_refresh and os.path.exists(absdir):
            curdir = os.getcwd()
            try:
                # Ensures paths are relative to the moduledir
                os.chdir(absdir)
                for root, dirs, files in os.walk(".", topdown=False):
                    saneroot = root[2:] if root.startswith("./") else root
                    for filename in files:
                        r = re_file.match(filename)
                        if r:
                            changed = True

                            fileinfo = r.groupdict()
                            module = fileinfo['module']
                            version = fileinfo['version']
                            format = fileinfo['format']

                            if module not in info:
                                info[module] = {}

                            if version not in info[module]:
                                info[module][version] = {}

                            if self.module is None or module == self.module:
                                info[module][version][format] = os.path.join(saneroot, filename)
                                continue

                        # If we arrive here, it means we ignored the file for some reason
                        if saneroot not in ignored:
                            ignored[saneroot] = []
                        ignored[saneroot].append(filename)
            finally:
                os.chdir(curdir)

        # XXX - maybe remove versions which lack tar.*

        self._info = info
        versions = {}
        if self.module:
            versions[self.module] = []
        for module in info.keys():
            versions[module] = sorted(info[module], version_cmp)
        self._versions = versions
        self._ignored = ignored

        if changed:
            # save the new information
            self.write_json()

    def determine_file(self, module, version, format, fuzzy=True):
        """Determine file using version and format

        If fuzzy is set, possibly return a compressed version of the given
        format."""
        if module not in self._info:
            return None, None

        if version not in self._info[module]:
            return None, None

        formats = [format]
        if fuzzy and not "." in format:
            formats.extend(("%s.%s" % (format, compression) for compression in ("gz", "bz2", "xz")))

        info_formats = self._info[module][version]
        for f in formats:
            if f in info_formats:
                return (os.path.join(self.relpath, info_formats[f]),
                        os.path.join(self.FTPROOT, self.relpath, info_formats[f]))

        return None, None

    def info_detailed(self, module, version, format, fuzzy=False):
        """Provides detailed information about file references by
        version and format.

        If fuzzy is set, possibly return a compressed version of the given
        format."""
        path, realpath = DirectoryInfo.determine_file(self, module, version, format, fuzzy)
        if realpath is None:
            return None

        stat = os.stat(realpath)
        return (path, realpath, human_size(stat.st_size), stat)

    def write_json(self):
        with open(self.jsonfile, 'w') as f:
            json.dump((self.JSONVERSION, self._info, self._versions, self._ignored), f)
            if self.GROUPID is not None:
                os.fchown(f.fileno(), -1, self.GROUPID)

    @property
    def info(self):
        return self._info

    @property
    def versions(self):
        return self._versions


class SuiteInfo(DirectoryInfo):

    def __init__(self, suite, version):
        majmin = re_version.sub(r'\1', version)
        relpath = os.path.join(suite, majmin, version)
        DirectoryInfo.__init__(self, relpath)


class ModuleInfo(DirectoryInfo):

    def __init__(self, module, section=DEFAULT_SECTION):
        self.module = module
        self.section = section

        relpath = os.path.join(self.section, self.module)
        DirectoryInfo.__init__(self, relpath, limit_module=module)

        # Determine maintainers
        self.maintainers = []
        data = get_module_info(self.module)
        if len(data):
            self.maintainers = data[0][1]['maintainerUid']

    @property
    def versions(self):
        return self._versions[self.module]

    def determine_file(self, version, format, fuzzy=True):
        return DirectoryInfo.determine_file(self, self.module, version, format, fuzzy)

    def info_detailed(self, version, format, fuzzy=False):
        return DirectoryInfo.info_detailed(self, self.module, version, format, fuzzy=False)


class InstallModule(BasicInfo):

    INSTALL_FORMATS = ('tar.gz', 'tar.bz2')

    def __init__(self, file, section=DEFAULT_SECTION):
        self.file = file

        self.uid = os.getuid()
        self.pw = pwd.getpwuid(self.uid)
        self.who = self.pw.pw_gecos
        self.who = re_who.sub("", self.who)
        if self.who == "":
            self.who = self.pw.pw_name

        self.section = section
        self.dirname, self.basename = os.path.split(file)
        self.fileinfo = TarInfo(file)

        if self.fileinfo.module is not None:
            self.module = self.fileinfo.module
            self.majmin = self.fileinfo.majmin
            self.version = self.fileinfo.version
            self.format = self.fileinfo.format

            self.destination = '%s/%s/%s/%s' % (self.FTPROOT, self.section, self.fileinfo.module, self.majmin)

            self.moduleinfo = ModuleInfo(self.fileinfo.module, section=self.section)
        else:
            self.moduleinfo = None
        self.prevversion = get_latest_version(self.moduleinfo.versions, self.version)



    def confirm_install(self):

        print """
      Module: %s
     Version: %s   (previous version: %s)
 Destination: %s/""" % (self.module, self.version, self.prevversion or 'N/A', self.destination)

        # Check if the module directory already exists. If not, the module name might contain a typo
        if not os.path.isdir('%s/%s/%s' % (self.FTPROOT, self.section, self.module)):
            print """
WARNING: %s is not present in the archive!
         Are you sure that it is new and/or the correct module name?""" % self.module

        print """
Install %s? [Y/n]""" % self.module,
        response = raw_input()

        if response != '' and response[0] != 'y' and response[0] != 'Y':
            print """Module installation cancelled."""

            return False

        # install the module
        return True

    def validate(self):
        if self.module is None:
            print >>sys.stderr, 'ERROR: Unrecognized module/version/file format. Make sure to follow a sane naming scheme (MAJOR.MINOR.MICRO)'
            return False

        # Don't allow an existing tarball to be overwritten
        if os.path.exists(os.path.join(self.destination, self.basename)):
            print >>sys.stderr, """ERROR: %s already exists in the archive!""" % self.basename
            if DEBUG:
                print >>sys.stderr, "DEBUG: Continuing anyway in debug mode"
            else:
                return False

        # XXX - verify if tarball is being installed by a maintainer

        # CHECK FOR CONSISTENCY
        sys.stdout.write(" - Checking consistency: ")
        errors = self.fileinfo.check(progress=True)
        if not errors:
            print ", done"
        else:
            print ", failed"
            for k, v in errors.iteritems():
                print >>sys.stderr, "ERROR: %s" % v

        # True if there are no errors
        return len(errors) == 0

    def install(self, unattended=False):
        print "Preparing installation of %s:" % self.basename
        # Validate the file
        if not self.validate():
            return False


        tmpdir = tempfile.mkdtemp(prefix='install_module')
        try:
            created_files = []
            # do we have a previous version?

            prev_tarinfo = None
            prev_relfile, prev_file = self.moduleinfo.determine_file(self.prevversion, 'tar') if self.prevversion else (None, None)
            if prev_file:
                prev_tarinfo = TarInfo(prev_file)


            constructor = lambda fn: self._make_tmp_file(tmpdir, fn)
            diffs = self.fileinfo.diff(self.fileinfo.file, prev_tarinfo, constructor, progress=True)

            for fn, f in diffs.iteritems():
                created_files.append(f.name)

            # Create tarball(s) according to INSTALL_FORMATS
            if self.format in self.INSTALL_FORMATS:
                sys.stdout.write(" - Copying %s" % self.format)
                with open(self.file, 'rb') as f1:
                    with self._make_tmp_file(tmpdir, self.format) as f2:
                        created_files.append(f2.name)
                        shutil.copyfileobj(f1, f2)
                print ", done"

            formats = [format for format in self.INSTALL_FORMATS if format != self.format]
            if len(formats):
                if len(formats) == 1:
                    sys.stdout.write(" - Creating %s from %s: " % (formats[0], self.format))
                else:
                    sys.stdout.write(" - Creating tarballs from %s: " % self.format)
                f2 = []
                for format in formats:
                    if len(formats) > 1:
                        sys.stdout.write("%s " % format)
                    f = self._make_tmp_file(tmpdir, format, constructor=self.FORMATS[format])
                    created_files.append(f.name)
                    f2.append(f)

                f1 = self.FORMATS[self.format](self.file, 'rb')
                while 1:
                    buf = f1.read(self.BLOCKSIZE)
                    if not buf:
                        break
                    for fdst in f2:
                        fdst.write(buf)
                        sys.stdout.write(".")
                for fdst in f2:
                    fdst.close()
                    f2 = []
                print ", done"



            sys.stdout.write(" - Creating sha256sum")
            with self._make_tmp_file(tmpdir, 'sha256sum') as f:
                cmd = ['sha256sum', '--']
                cmd.extend([os.path.basename(fn) for fn in created_files if os.path.isfile(fn)])
                subprocess.call(cmd, stdout=f, cwd=tmpdir)
            print ", done"

            # Ask user if tarball should be installed
            if not unattended:
                if not self.confirm_install():
                    return False

        #        if not os.path.isdir(self.destination):
        #            os.makedirs(self.destination, 042775) # drwxrwsr-x
                # XXX - install the tarball
                # XXX - change ownership of the tarball
        finally:
            # cleanup temporary directory
            if not DEBUG:
                shutil.rmtree(tmpdir)
            else:
                print "DEBUG: Not removing temporary directory: %s" % tmpdir

        sys.stdout.write(" - Updating known versions")
        self.moduleinfo.refresh()
        print ", done"

        self.inform()
        return True

    def _make_tmp_file(self, tmpdir, format, constructor=open):
        fn = os.path.join(tmpdir, '%s-%s.%s' % (self.module, self.version, format))
        f = constructor(fn, 'w')
        if self.GROUPID is not None:
            os.chown(fn, -1, self.GROUPID)
        return f

    def inform(self):
        """Inform regarding the new release"""
        print "Doing notifications:"
        if self.version not in self.moduleinfo.info:
            return False

        sha256sum = {}
        sys.stdout.write(" - Informing ftp-release-list")

        mail = StringIO()

        info = self.moduleinfo.info_detailed(self.version, 'sha256sum')
        if info is not None:
            path, realpath, size, stat = info
            with open(realpath, "r") as f:
                for line in f.read().splitlines():
                    # XXX - the checksum filed could look differently (binary indicator)
                    if '  ' in line:
                        checksum, file = line.partition('  ')[::2]
                        sha256sum[file] = checksum
                    else:
                        print "WARN: Strange sha256sum line: %s" % line
        else:
            print "WARN: Couldn't determine sha256sum file?!?"

        print >>mail, """       Module: %s
      Version: %s
  Uploaded by: %s
""" % (self.module, self.version, self.who)

        for format in self.FORMATS:
            info = self.moduleinfo.info_detailed(self.version, format)
            if info is not None:
                path, realpath, size, stat = info
                dirname, basename = os.path.split(path)
                print >>mail, "%s/%s" % (self.URLROOT, path)
                if basename in sha256sum:
                    print >>mail, " sha256sum: %s" % sha256sum[basename]
                print >>mail, "      size: %s" % size
                print >>mail, ""

        dump_files = [
            ('news', 'News'),
            ('changes', 'ChangeLog')
        ]
        show_contents = True
        for format, formatname in dump_files:
            info = self.moduleinfo.info_detailed(self.version, format)
            if info is not None:
                path, realpath, size, stat = info
                if show_contents and stat.st_size < 50000:
                    with open(realpath, 'r') as f:
                        line = f.readline()
                        if not self.version in line:
                            print >>mail, formatname
                            print >>mail, "-" * len(formatname)
                            print >>mail, ""
                        mail.write(line)
                        shutil.copyfileobj(f, mail)
                else:
                    print >>mail, formatname
                    print >>mail, "-" * len(formatname)
                    mail.write("%s/%s  (%s)" % (self.URLROOT, path, size))
                print >>mail, ""
                # Only show the contents of the first found file, URLs for the rest
                show_contents = False


        mail.seek(0)
        subject = '%s %s' % (self.module, self.version)
        to = "FTP Releases <ftp-release-list@gnome.org>"
        retcode = self._send_email(mail.read(), subject, to, ['olav@vitters.nl'],
                                   {'Reply-To': 'desktop-devel-list@gnome.org'}
        )
        print ", done"

        sys.stdout.write(" - Triggering GNOME library update")
        subject = 'GNOME_GIT library-web'
        to = "gnomeweb@www.gnome.org"
        retcode = self._send_email("forced", subject, to, ['olav@vitters.nl'])
        print ", done"

        sys.stdout.write(" - Adding new version to GNOME Bugzilla")
        cmd = ['/usr/bin/curl', '-q', '-L', 'https://bugzilla.gnome.org/add-version.cgi?%s|%s' % (self.module, self.version)]
        self._call_cmd(cmd)

        sys.stdout.write(" - Triggering ftp.gnome.org update")
        syncscript = ['/usr/local/bin/signal-ftp-sync']
        if self._call_cmd(cmd):
            print ""
            print "Your tarball will appear in the following location on ftp.gnome.org:"
            print ""
            print "  %s" % "/".join((self.URLROOT, self.section, self.module, self.majmin, ""))
            print ""
            print "It is important to retain the trailing slash for compatibility with"
            print "broken http clients, and to use http as it is less taxing on the server."
            info = self.moduleinfo.info_detailed(self.version, 'sha256sum')
            if info is not None:
                print ""
                path, realpath, size, stat = info
                with open(realpath, "r") as f:
                    shutil.copyfileobj(f, sys.stdout)


    def _call_cmd(self, cmd):
        """Calls a certain command and shows progress

        Note: returns True even if exit code is not zero."""

        if not os.path.isfile(cmd[0]):
            print ", FAILED (cannot find %s)" % cmd[0]
            print "PLEASE INFORM gnome-sysadmin@gnome.org ASAP!!!"

            return False

        if DEBUG:
            print ", ignored (debug mode)"
            return True

        retcode = subprocess.call(cmd)
        if retcode == 0:
            print ", done"
        else:
            print "FAILED (exit code %s)" % retcode

        return True


    def _send_email(self, contents, subject, to, smtp_to, headers=None):
        """Send an email"""
        msg = MIMEText(contents, _charset='utf-8')
        msg['Subject'] = subject
        msg['From'] = '"%s" <install-module@master.gnome.org>' % self.who
        msg['To'] = to
        if headers is not None:
            for k, v in headers.iteritems():
                msg[k] = v

        if DEBUG:
            smtp_to = ['olav@vitters.nl']

        # Call sendmail program directly so it doesn't matter if the service is running
        cmd = ['/usr/sbin/sendmail', '-oi', '-f', 'noreply@gnome.org', '--']
        cmd.extend(smtp_to)
        p = subprocess.Popen(cmd, stdin=subprocess.PIPE)
        p.stdin.write(msg.as_string())
        p.stdin.flush()
        p.stdin.close()
        return p.wait()





l = None
def get_module_info(module):
    global l # evil

    if l is None:
        l = ldap.open('ldap-back')
        l.protocol_version = ldap.VERSION3

    filter = ldap.filter.filter_format("(cn=%s)", (module, ))
    data = l.search_s (LDAP_BASE, ldap.SCOPE_SUBTREE, filter, None)

    return data

def cmd_install(options, parser):
    tarballs = [file for file in options.tarball if os.path.exists(file)]

    if not len(tarballs):
        parser.print_help()
        sys.exit(2)

    sys.stdout.write("Gathering information and sorting on version: ")
    modules = []
    for tarball in tarballs:
        modules.append(InstallModule(tarball))
        sys.stdout.write(".")
    print ", done"
    modules.sort(cmp=lambda x,y:
                     x.module and y.module and (cmp(x.module, y.module) 
                                                or version_cmp(x.version, y.version)))

    for module in modules:
        module.install(unattended=options.unattended)
        print ""

    print """Please report any problems while running this script to:
https://bugzilla.gnome.org/enter_bug.cgi?product=sysadmin"""

def cmd_show_info(options, parser):
    import glob
    import datetime

    modules = [os.path.basename(path) for path in glob.glob(os.path.join(BasicInfo.FTPROOT, options.section, '*')) if os.path.isdir(path)]
    for module in modules:
        moduleinfo = ModuleInfo(module, options.section)
        version = moduleinfo.versions[-1] if len(moduleinfo.versions) else ""
        changed = ""
        if version:
            info = moduleinfo.info_detailed(version, 'tar.gz')
            if info:
                path, realpath, size, stat = info
                changed = datetime.date.fromtimestamp(stat.st_ctime).isoformat()

        print "\t".join((module, version, changed, ", ".join(moduleinfo.maintainers)))

def cmd_sudo(options, parser):
    print >>sys.stderr, "ERROR: Not yet implemented!"
    sys.exit(2)

def cmd_validate_tarballs(options, parser):
    print options.module, options.section
    moduleinfo = ModuleInfo(options.module, section=options.section)
    for version in moduleinfo.versions:
        print "Version: %s" % version
        for format in BasicInfo.FORMATS:
            info = moduleinfo.info_detailed(version, format)
            if info is not None:
                path, realpath, size, stat = info

                prev_fileinfo = TarInfo(realpath)
                sys.stdout.write(" - Checking %s: " % format)
                errors = prev_fileinfo.check(progress=True)
                if errors:
                    print ", FAILED"
                    for k, v in errors.iteritems():
                        print "ERROR: %s" % v
                else:
                    print ", success"


def cmd_release_diff(options, parser, header=None):
    oldversion = SuiteInfo(options.suite, options.oldversion)
    newversion = SuiteInfo(options.suite, options.newversion)

    did_header = False

    modules = set()
    modules.update(oldversion.versions.keys())
    modules.update(newversion.versions.keys())
    for module in sorted(modules):
        oldmodulever = oldversion.versions.get(module, ('-none-',))[-1]
        newmodulever = newversion.versions.get(module, ('-none-',))[-1]

        if newmodulever == oldmodulever:
            newmodulever = '-same-'
        elif options.same:
            # Only show modules which are the same
            continue

        if not did_header and header:
            did_header = True
            print header
            print ""
        print "%-25s %-10s %-10s" % (module, oldmodulever, newmodulever)

    if did_header:
        print ""

def cmd_simple_diff(options, parser):
    for suite in SUITES:
        options.suite = suite

        cmd_release_diff(options, parser, header="== %s ==" % suite)

def cmd_release_news(options, parser, header=None):
    def moduleprint(modules, header):
        if modules:
            print header
            for module in sorted(modules):
                print " - %s " % module
            print ""
    oldversion = SuiteInfo(options.suite, options.oldversion)
    newversion = SuiteInfo(options.suite, options.newversion)

    oldmodules = set(oldversion.versions.keys())
    newmodules = set(newversion.versions.keys())
    modules = set()
    modules.update(oldmodules)
    modules.update(newmodules)

    addedmodules = newmodules - oldmodules
    removedmodules = oldmodules - newmodules
    samemodules = oldmodules & newmodules
    moduleprint(addedmodules, "The following modules have been added in this release")
    moduleprint(removedmodules, "The following modules have been removed in this release")

    news = {}
    sameversions = set()
    header = "The following modules have a new version"
    did_header = False
    for module in sorted(samemodules):
        show_contents = True
        newmodulever = newversion.versions.get(module, (None,))[-1]
        new_relfile, new_file = newversion.determine_file(module, newmodulever, 'tar') if newmodulever else (None, None)

        prevmodulever = oldversion.versions.get(module, (None,))[-1]
        prev_relfile, prev_file = oldversion.determine_file(module, prevmodulever, 'tar') if prevmodulever else (None, None)

        if not new_file:
            continue

        if newmodulever == prevmodulever:
            sameversions.add(module)
            continue

        if not did_header:
            print header
            did_header=True
        print " - %s (%s => %s)" % (module, prevmodulever or '-none-', newmodulever or '-none')


        fn = 'NEWS'

        new_tarinfo = TarInfo(new_file)
        new_errors = new_tarinfo.check()
        if new_errors:
            continue

        prev_tarinfo = TarInfo(prev_file) if prev_file else None

        constructor = lambda fn: StringIO()
        diffs = new_tarinfo.diff((fn, ), prev_tarinfo, constructor, progress=False)

        if fn in diffs:
            f = diffs[fn]
            f.seek(0)
            news[module] = f.read()
    if did_header:
        print ""

    moduleprint(sameversions, "The following modules weren't upgraded in this release")
    moduleprint(news, "Modules with detailed change information")

    for module in sorted(news):
        print "========================================"
        print "  %s" % module
        print "========================================"
        print ""
        print news[module]


def main():
    try:
        groupid = grp.getgrnam(GROUP)[2]
    except KeyError:
        print >>sys.stderr, 'FATAL: Group %s does NOT exist!' % GROUP
        print >>sys.stderr, 'FATAL: Please inform gnome-sysadmin@gnome.org!'
        sys.exit(1)

    if groupid is None or (os.getgid() != groupid and groupid not in os.getgroups()):
        print 'FATAL: Script requires membership of the %s group' % GROUP
        sys.exit(1)

    BasicInfo.GROUPID = groupid

    usage = "usage: %prog [options] TARBALL [TARBALL ...]"
    description = """Install new tarball(s) to GNOME FTP master and make it available on the mirrors."""

    epilog="""Report bugs to gnome-sysadmin@gnome.org"""
    parser = argparse.ArgumentParser(description=description,epilog=epilog)


    # SUBPARSERS
    subparsers = parser.add_subparsers(title='subcommands')
    #   install
    subparser = subparsers.add_parser('install', help='install a module to %s' % BasicInfo.URLROOT)
    subparser.add_argument("-f", "--force", action="store_true", dest="clobber",
                           help="Overwrite the original tarball")
    subparser.add_argument("-u", "--unattended", action="store_true",
            help="do not prompt for confirmation.\n\nNOTE: An unattended install " +
            "will not provide any extra information to help you avoid an invalid " +
            "(and potentially messy) installation. It is recommended that you do not " +
            "use this unless you are *very* sure.")
    subparser.add_argument('tarball', nargs='+', help='Tarball(s) to install')
    subparser.add_argument("-s", "--section", choices=SECTIONS,
                           help="Section to install the file to")
    subparser.set_defaults(
        func=cmd_install, clobber=False, unattended=False, section=DEFAULT_SECTION
    )
    #   show-info
    subparser = subparsers.add_parser('show-info', help='show module information')
    subparser.add_argument("-s", "--section", choices=SECTIONS,
                           help="Section to install the file to")
    subparser.set_defaults(func=cmd_show_info, section=DEFAULT_SECTION)
    #   sudo
    subparser = subparsers.add_parser('sudo', help='install tarballs uploaded using rsync')
    subparser.set_defaults(func=cmd_sudo)
    #   validate-tarballs
    subparser = subparsers.add_parser('validate-tarballs', help='validate all tarballs for a given module')
    subparser.add_argument("-s", "--section", choices=SECTIONS,
                           help="Section to install the file to")
    subparser.add_argument('module', help='Module to validate')
    subparser.set_defaults(func=cmd_validate_tarballs, section=DEFAULT_SECTION)

    # release-diff
    subparser = subparsers.add_parser('release-diff', help='show differences between two GNOME suite versions')
    subparser.add_argument("-s", "--suite", choices=SUITES,
                           help='Suite to compare')
    subparser.add_argument("--same", action="store_true",
                           help='Only show modules which have not changed')
    subparser.add_argument('oldversion', metavar='OLDVERSION', help='Previous GNOME version')
    subparser.add_argument('newversion', metavar='NEWVERSION', help='New GNOME version')
    subparser.set_defaults(func=cmd_release_diff, suite=DEFAULT_SUITE)
    # simple-diff
    subparser = subparsers.add_parser('simple-diff', help='Show differences between two GNOME versions in all suites')
    subparser.add_argument("--same", action="store_true",
                           help='Only show modules which have not changed')
    subparser.add_argument('oldversion', metavar='OLDVERSION', help='Previous GNOME version')
    subparser.add_argument('newversion', metavar='NEWVERSION', help='New GNOME version')
    subparser.set_defaults(func=cmd_simple_diff)
    # release-news
    subparser = subparsers.add_parser('release-news', help='show news between two GNOME suite versions')
    subparser.add_argument("-s", "--suite", choices=SUITES,
                           help='Suite to compare')
    subparser.add_argument('oldversion', metavar='OLDVERSION', help='Previous GNOME version')
    subparser.add_argument('newversion', metavar='NEWVERSION', help='New GNOME version')
    subparser.set_defaults(func=cmd_release_news, suite=DEFAULT_SUITE)


    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(2)

    options = parser.parse_args()

    old_mask = os.umask(0002)

    if DEBUG:
        print "WARNING: Running in DEBUG MODE!"

    try:
        options.func(options, parser)
    except KeyboardInterrupt:
        print('Interrupted')
        sys.exit(1)
    except EOFError:
        print('EOF')
        sys.exit(1)
    except IOError, e:
        if e.errno != errno.EPIPE:
            raise
        sys.exit(0)



if __name__ == "__main__":
    main()
