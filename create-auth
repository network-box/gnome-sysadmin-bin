#!/usr/bin/python
import ldap
import ldap.filter
import grp
import os
import tempfile
import sys
import subprocess
import shutil
import time
import random
try:
    import hashlib as md5
except:
    import md5

def get_md5sum_hash():
    dir = "/etc/sshd/users/"
    user_md5sums = {}
    file_list = os.listdir (dir)
    for file in file_list:
        path = os.path.join(dir, file, "authorized_keys")
        if os.path.isfile (path):
            f = open (path)
            str = f.read ()
            f.close ()
            m = md5.md5(str)
            user_md5sums [file] = m.hexdigest ()
    return user_md5sums

## first you must open a connection to the server
try:
    l = ldap.open("ldap.gnome.org")
    l.simple_bind("cn=Manager,dc=gnome,dc=org")
except ldap.LDAPError, e:
    print >>sys.stderr, e
    sys.exit(1)

RESTRICTS = {
    'gnomegit-i18n':
        'command="/home/admin/bin/run-git-or-special-cmd",no-pty,no-port-forwarding,from="91.189.93.2" ',
    'mango':
        'command="/home/admin/bin/run-mango-special-cmd",no-pty,no-port-forwarding ',
    'rrsync':
        'command="/home/admin/bin/run-rrsync-or-special-cmd /ftp/scratch",no-user-rc,no-pty,no-port-forwarding ',
    'gnomegit':
        'command="/home/admin/bin/run-git-or-special-cmd",no-pty,no-port-forwarding ',
    'nagios':
        'command="/home/admin/bin/run-nagios-command",no-pty,no-port-forwarding ',
}
LDAP_GROUP_BASE='ou=groups,dc=gnome,dc=org'
LDAP_USER_BASE='ou=people,dc=gnome,dc=org'


def _get_group_from_ldap(group):

    filter = ldap.filter.filter_format('(&(objectClass=posixGroup)(cn=%s))', (group, ))
    results = l.search_s(LDAP_GROUP_BASE, ldap.SCOPE_SUBTREE, filter, ('memberUid', ))

    members = set()
    for entry in results:
        id = entry[0]
        attr = entry[1]

        members.update(attr['memberUid'])

    return members

def _get_user_data_from_ldap(filter):
    if options.random_sleep:
	    time.sleep(random.randint(0, 600))

    user_data = {}
    try:
        searchattrs = ('uid', 'homeDirectory', 'authorizedKey',
                       'uidNumber', 'gidNumber')
        persona_data = l.search_s ("ou=people,dc=gnome,dc=org",
                                   ldap.SCOPE_SUBTREE, filter, searchattrs)
    except ldap.LDAPError, e:
        print >>sys.stderr, e
        sys.exit(1)

    if not len(persona_data):
        return user_data

    for dn, person_info in persona_data:
        key_list = person_info['authorizedKey']
        key_list.sort ()

        uid = person_info['uid'][0]

        user_data[uid] = {
            'uid': uid,
            'authorizedKey': key_list,
            'uidNumber': person_info['uidNumber'][0],
            'gidNumber': person_info['gidNumber'][0],
            'homeDirectory': person_info['homeDirectory'][0],
        }

    return user_data

def get_homedirs(limit_uids=None):
    uids = {}
    if limit_uids is not None and not limit_uids:
        # uids have been restricted and there are no uids to create a homedir for
        return uids

    if limit_uids:
        format = '(uid=%s)' * len(limit_uids)
        filter = '(|%s)' % ldap.filter.filter_format(format, list(limit_uids))
    else:
        filter = ""

    filter = '(&(!(homeDirectory=/))(authorizedKey=*)%s)' % filter

    return _get_user_data_from_ldap(filter)

def create_home_directories(uids_data):
    src = '/etc/skel'
    created_uids = set()
    for uid, user in uids_data.iteritems():
        dst = user['homeDirectory']
        if dst != '/home/users/%s' % uid or os.path.isdir(dst):
            continue

        shutil.copytree(src, dst, True)
        subprocess.call(['/bin/chown', '-R', '%s:%s' % (user['uidNumber'], user['gidNumber']), dst ])
        created_uids.add(uid)

    if created_uids:
        set_homedir_permissions(uids_data, created_uids)

    return created_uids

PERMISSIONS = [
    # Path, directory?, contents
    # generic
    ('.login', False, None),
    ('.logout', False, None),
    # bash specific
    ('.bashrc', False, """# look in .bashrc_custom
if [ -z "$BASH_EXECUTION_STRING" -a -z "$SSH_ORIGINAL_COMMAND" ]; then
    if [ -f ~/.bashrc_custom ]; then
        source ~/.bashrc_custom
    fi
else
    if [ -z "$HOME_ORIG" ]; then
        HOME_ORIG="$HOME"
        HOME=/
        export HOME
        export HOME_ORIG
    fi
fi
"""),
    ('.bash_profile', False, """# look in .bash_profile_custom
if [ -z "$BASH_EXECUTION_STRING" -a -z "$SSH_ORIGINAL_COMMAND" ]; then
    if [ -f ~/.bash_profile_custom ]; then
        source ~/.bash_profile_custom
    fi
else
    if [ -z "$HOME_ORIG" ]; then
        HOME_ORIG="$HOME"
        HOME=/
        export HOME
        export HOME_ORIG
    fi
fi
"""),
    ('.bash_login', False, None),
    ('.bash_logout', False, None),
    # tcsh / csh specific
    ('.cshrc', False, None),
    ('.tcshrc', False, """
if( ( ! $?SSH_ORIGINAL_COMMAND ) && ( ! $?command ) ) then
    if ( -f ~/.tcsh_custom ) then
        source ~/.tcsh_custom
    endif
else
    set histfile=/dev/null
    set dirsfile=/dev/null

    if( ! $?HOME_ORIG ) then
        setenv HOME_ORIG "$HOME"
        setenv HOME "/"
    endif
endif
"""),
    # don't care about zsh
    ('.zshenv', False, None),
    ('.zprofile', False, None),
    ('.zshrc', False, None),
    ('.zlogin', False, None),
    ('.zlogout', False, None),
    # ssh
    ('.ssh', True, None),
    ('.ssh/rc', False, None),
    ('.ssh/known_hosts', False, -1), # only ensure file exists, do not touch if it does

]

def splitter(l, n):
    i = 0
    chunk = l[:n]
    while chunk:
        yield chunk
        i += n
        chunk = l[i:i+n]

def set_homedir_permissions(user_data, created_users):
    if not created_users:
        return False

    delayed = []
    for u in created_users:
        if u not in user_data:
            continue

        user = user_data[u]
        homedir = user['homeDirectory']
        uid = int(user['uidNumber'])
        gid = int(user['gidNumber'])
        sysadmin = user.get('sysadmin', False)

        if homedir == '/':
            continue

        for relpath, isdir, contents in PERMISSIONS:
            abspath = os.path.join(homedir, relpath)
            if isdir:
                if not os.path.exists(abspath):
                    os.mkdir(abspath)
                os.lchown(abspath, uid, gid)
                delayed.append(abspath)
            else:
                can_rename = contents is not None and isinstance(contents, basestring)
                can_wipe = contents is None or isinstance(contents, basestring)
                can_write = can_wipe
                custom = '%s_custom' % abspath

                if os.path.exists(abspath):
                    if can_rename:
                        if not os.path.exists(custom):
                            os.rename(abspath, custom)
                    elif can_wipe:
                        os.remove(abspath)
                else:
                    if sysadmin and can_rename:
                        # make sure the custom file exists
                        f = open(custom, 'w')
                        os.lchown(custom, uid, gid)
                        f.close()

                    if not can_wipe:
                        can_write = True

                if sysadmin and can_rename:
                    delayed.append(custom)

                # ensure file exists
                if can_write:
                    f = open(abspath, 'w')
                    if isinstance(contents, basestring):
                        f.write(contents)
                    os.lchown(abspath, uid, gid)
                    f.close()

                # change flags
                if can_wipe:
                    delayed.append(abspath)

    if delayed:
        for paths in splitter(delayed, 50):
            subprocess.call(['/usr/bin/chattr', '+i', '--'] + paths)

def get_uids_from_wheel():
    try:
        wheelinfo = grp.getgrnam ('wheel')
    except KeyError:
        wheelinfo = grp.getgrnam ('admin')

    people = wheelinfo[3]
    return set(filter (lambda x: x != 'root', people))

_cache_group = {}
def get_uids_from_group(group, force_ldap=False):
    if group in _cache_group:
        return _cache_group[group]

    if force_ldap:
        people = _get_group_from_ldap(group)
    else:
        try:
            people = set(grp.getgrnam (group)[3])
        except KeyError:
            # Server doesn't have an LDAP connection -- probably the label server
            people = _get_group_from_ldap(group)

    people.discard('root')
    people.discard('sysadmin')

    _cache_group[group] = people
    return _cache_group[group]

def lookup_user_info(uids):
    format = '(uid=%s)' * len(uids)
    filter = ldap.filter.filter_format(format, list(uids))
    if len(uids) > 0:
        filter = '(|%s)' % filter
    filter = '(&%s(authorizedKey=*))' % filter

    return _get_user_data_from_ldap(filter)

def build_user_hash(group_list, options):
    users = set()
    gnomevcs_users = set()

    # get a list of all the users.  Keep them in a hashtable to avoid duplicates
    wheel = get_uids_from_wheel()
    sysadmin = get_uids_from_group('sysadmin')
    print_user_list('Ex-sysadmins to be removed from wheel', wheel - sysadmin)
    users.update(wheel)
    users.update(sysadmin)
    for group in group_list:
        users.update(get_uids_from_group(group, force_ldap=True))
    if options.restrict in ('gnomegit', 'mango'):
        gnomevcs_users = (get_uids_from_group('gnomecvs', force_ldap=True) | get_uids_from_group('gnomevcs', force_ldap=True)) - users
        if options.translation_user:
            gnomevcs_users.update(['translations'])
    elif options.restrict == 'nagios':
	gnomevcs_users = get_uids_from_group('nagios', force_ldap=True) - users
    elif options.restrict == 'rrsync':
        gnomevcs_users = get_uids_from_group('ftpbasic', force_ldap=True) - users

    # look up their keys (if we have them)
    user_data = lookup_user_info(users | gnomevcs_users)

    for uid in gnomevcs_users:
        if uid not in user_data:
            continue

        if options.restrict == 'gnomegit' and options.translation_user and uid == 'translations':
            user_data[uid]['restrict'] = 'gnomegit-i18n'
        else:
            user_data[uid]['restrict'] = restrict

    for uid in wheel | sysadmin:
        if uid not in user_data:
            continue

        user_data[uid]['sysadmin'] = True

    return user_data

def create_directory_structure (user_data):
    base_directory_name = tempfile.mktemp ('-sshd')
    sshd_directory_name = base_directory_name + "/sshd"
    users_directory_name = sshd_directory_name + "/users"
    os.mkdir (base_directory_name, 0700)

    try:
        os.mkdir (sshd_directory_name, 0711)
        os.mkdir (users_directory_name, 0711)

        # make a users dir
        for uid, user in user_data.iteritems():
            user_dir_name = users_directory_name + "/" + user['uid']
            authorized_keys_file = user_dir_name + "/authorized_keys"
            os.mkdir (user_dir_name, 0700)
            os.chown (user_dir_name, int(user['uidNumber']), int (user['gidNumber']))
            file = open (authorized_keys_file, "w")
            for key in user['authorizedKey']:
                restrict = user.get('restrict', None)
                if restrict:
                    file.write(RESTRICTS[restrict])
                file.write (key)
                file.write ("\n")
            file.close()
            os.chmod (authorized_keys_file, 0700)
            os.chown (authorized_keys_file, int (user['uidNumber']), int (user['gidNumber']))

        # We special case root
        if os.path.isfile ("/root/.ssh/authorized_keys"):
            user_dir_name = users_directory_name + "/root"
            authorized_keys_file = user_dir_name + "/authorized_keys"
            os.mkdir (user_dir_name, 0700)
            os.chown (user_dir_name, 0, 0)
            shutil.copy2('/root/.ssh/authorized_keys', authorized_keys_file)

    except Exception, e:
        shutil.rmtree(base_directory_name)
        raise

    return base_directory_name


def print_user_list (description, user_list):
    if not user_list:
        return

    user_len = len (user_list)
    if user_len == 1:
        print description + " %d user:" % user_len
    else:
        print description + " %d users:" % user_len
    for user in sorted(user_list):
        print "\t%s" % user
    print

def print_comparison (initial_user_hash, post_user_hash):
    removed_users = []
    new_users = []
    changed_users = []
    # go through the list of initial
    for user, hash in initial_user_hash.iteritems():
        try:
            post_hash = post_user_hash [user]
            if post_hash != hash:
                changed_users.append (user)
            del post_user_hash [user]
        except KeyError:
            removed_users.append (user)
    for user in post_user_hash.iterkeys():
        new_users.append (user)

    print_user_list ("Added", (new_users))
    print_user_list ("Removed", (removed_users))
    print_user_list ("Changed", (changed_users))

if __name__ == '__main__':
    from optparse import OptionParser
    parser = OptionParser()
    parser.add_option("--restrict",
                      action="store", dest="restrict", default=None,
                      choices=['gnomegit', 'mango', 'rrsync', 'nagios'],
                      help="What type of restricted access to setup")

    parser.add_option("--gnomegit",
                      action="store_const", dest="restrict", const="gnomegit")
    parser.add_option("--rrsync",
                      action="store_const", dest="restrict", const="rrsync")
    parser.add_option("--mango",
                      action="store_const", dest="restrict", const="mango")
    parser.add_option("--nagios",
                      action="store_const", dest="restrict", const="nagios")
    parser.add_option("--translation-user", action="store_true")

    parser.add_option("--create-all-homedirs",
                      action="store_const", dest="homedirs", const="all")
    parser.add_option("--create-homedirs",
                      action="store_const", dest="homedirs", const="basic")

    parser.add_option("--random-sleep",  action="store_true", 
                      help="Sets a random sleep time before executing the script, useful to not overload ldap-back")

    parser.set_defaults(homedirs=None)

    (options, group_list) = parser.parse_args()

    if options.homedirs is not None:
        import stat

    if options.translation_user and options.restrict != 'gnomegit':
        print >>sys.stderr, "ERROR: --translation-user only works for --gnome-git"
        sys.exit(1)

    if options.homedirs == 'all':
        user_list_homedirs = get_homedirs()
        old_mask = os.umask(0077)
        created_users = create_home_directories(user_list_homedirs)
        os.umask(old_mask)
        print_user_list('Created home directory for', created_users)
#        set_homedir_permissions(user_list_homedirs, user_list_homedirs.keys())

    user_data = build_user_hash (group_list, options)
    if not len(user_data):
        print >>sys.stderr, "ERROR: No users to create! Likely empty LDAP directory!!"
        sys.exit(1)

    if options.homedirs == 'basic':
        old_mask = os.umask(0077)
        created_users = create_home_directories(user_data)
        os.umask(old_mask)
        print_user_list('Created home directory for', created_users)

    base_directory_name = create_directory_structure(user_data)
    try:
        initial_user_hash = get_md5sum_hash ()
        status = subprocess.call(['rsync', '-aq', '--delete', '%s/sshd/' % base_directory_name, '/etc/sshd/'])
        if status != 0:
            print >>sys.stderr, "Error in rsync of files:"
            sys.exit (status)

        post_user_hash = get_md5sum_hash ()
    finally:
        shutil.rmtree(base_directory_name)

    print_comparison (initial_user_hash, post_user_hash)
