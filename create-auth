#!/usr/bin/python
import ldap
import ldap.filter
import grp
import os
import tempfile
import sys
import subprocess
import shutil
try:
    import hashlib as md5
except:
    import md5

def get_md5sum_hash():
    dir = "/etc/sshd/users/"
    user_md5sums = {}
    file_list = os.listdir (dir)
    for file in file_list:
        path = os.path.join(dir, file, "authorized_keys")
        if os.path.isfile (path):
            f = open (path)
            str = f.read ()
            f.close ()
            m = md5.md5(str)
            user_md5sums [file] = m.hexdigest ()
    return user_md5sums

## first you must open a connection to the server
try:
    l = ldap.open("ldap-back")
    l.simple_bind("cn=Manager,dc=gnome,dc=org")
except ldap.LDAPError, e:
    print e
    sys.exit(1)

RESTRICTS = {
    'gnomegit-i18n':
        'command="/home/admin/bin/run-git-or-special-cmd",no-pty,no-port-forwarding,host="91.189.93.2" ',
    'mango':
        'command="/home/admin/bin/run-mango-special-cmd",no-pty,no-port-forwarding ',
    'rrsync':
        'command="/home/admin/bin/run-rrsync-or-special-cmd /ftp/scratch",no-user-rc,no-pty,no-port-forwarding ',
    'gnomegit':
        'command="/home/admin/bin/run-git-or-special-cmd",no-pty,no-port-forwarding '
}
LDAP_GROUP_BASE='ou=groups,dc=gnome,dc=org'
LDAP_USER_BASE='ou=people,dc=gnome,dc=org'


_cache_group = {}
def get_uids_from_group(group):
    if group in _cache_group:
        return _cache_group[group]

    filter = ldap.filter.filter_format('(&(objectClass=posixGroup)(cn=%s))', (group, ))
    results = l.search_s(LDAP_GROUP_BASE, ldap.SCOPE_SUBTREE, filter, ('memberUid', ))

    members = set()
    for entry in results:
        id = entry[0]
        attr = entry[1]

        members.update(attr['memberUid'])

    _cache_group[group] = members
    return members

def _lookup_from_ldap(filter):
    user_data = {}
    try:
        searchattrs = ('uid', 'homeDirectory', 'authorizedKey',
                       'uidNumber', 'gidNumber')
        persona_data = l.search_s ("ou=people,dc=gnome,dc=org",
                                   ldap.SCOPE_SUBTREE, filter, searchattrs)
    except ldap.LDAPError, e:
        print e
        sys.exit(1)

    if not len(persona_data):
        return user_data

    for dn, person_info in persona_data:
        key_list = person_info['authorizedKey']
        key_list.sort ()

        uid = person_info['uid'][0]

        user_data[uid] = {
            'uid': uid,
            'authorizedKey': key_list,
            'uidNumber': person_info['uidNumber'][0],
            'gidNumber': person_info['gidNumber'][0],
            'homeDirectory': person_info['homeDirectory'][0],
        }

    return user_data

def get_homedirs(limit_uids=None):
    uids = {}
    if limit_uids is not None and not limit_uids:
        # uids have been restricted and there are no uids to create a homedir for
        return uids

    if limit_uids:
        format = '(uid=%s)' * len(limit_uids)
        filter = '(|%s)' % ldap.filter.filter_format(format, list(limit_uids))
    else:
        filter = ""

    filter = '(&(!(homeDirectory=/))(authorizedKey=*)%s)' % filter

    return _lookup_from_ldap(filter)

def create_home_directories(uids_data):
    src = '/etc/skel'
    created_uids = set()
    for uid, data in uids_data.iteritems():
        dst = data['homeDirectory']
        if dst != '/home/users/%s' % uid or os.path.isdir(dst):
            continue

        print "would create homedir: %s %s" % (uid, dst)
        continue

        shutil.copytree(src, dst, True)
        subprocess.call(['/bin/chown', '-R', '%s:%s' % (uid, uid), dst ])
        created_uids.add(uid)

    return created_uids

def get_uids_from_wheel():
    try:
        wheelinfo = grp.getgrnam ('wheel')
    except KeyError:
        wheelinfo = grp.getgrnam ('admin')

    people = wheelinfo[3]
    return filter (lambda x: x != 'root', people)

def get_uids_from_sysadmin():
    # XXX 
    try:
        people = grp.getgrnam ('sysadmin')[3]
    except KeyError:
        # Server doesn't have an LDAP connection -- probably the label server
        people = get_uids_from_group('sysadmin')

    return filter (lambda x: x != 'root' and x != 'sysadmin', people)

def lookup_user_info(uids):
    format = '(uid=%s)' * len(uids)
    filter = ldap.filter.filter_format(format, list(uids))
    if len(uids) > 0:
        filter = '(|%s)' % filter
    filter = '(&%s(authorizedKey=*))' % filter

    return _lookup_from_ldap(filter)

def build_user_hash(group_list, restrict=None):
    users = set()
    gnomevcs_users = set()

    # get a list of all the users.  Keep them in a hashtable to avoid duplicates
    wheel = set(get_uids_from_wheel())
    sysadmin = set(get_uids_from_sysadmin())
    print_user_list('Sysadmins not in wheel', sysadmin - wheel)
    print_user_list('Ex-sysadmins to be removed from wheel', wheel - sysadmin)
    users.update(wheel)
    users.update(sysadmin)
    for group in group_list:
        users.update(get_uids_from_group(group))
    if restrict in ('gnomegit', 'gnomegit-i18n', 'mango'):
        gnomevcs_users = (get_uids_from_group('gnomecvs') | get_uids_from_group('gnomevcs')) - users
        if restrict == 'gnomegit+i18n':
            gnomevcs_users.update(['translations'])
    elif restrict == 'rrsync':
        gnomevcs_users = get_uids_from_group('ftpbasic') - users

    # look up their keys (if we have them)
    user_data = lookup_user_info(users | gnomevcs_users)

    for uid in gnomevcs_users:
        if uid in user_data:
            if restrict == 'gnomegit-i18n':
                if uid == 'translations':
                    user_data[uid]['restrict'] = 'gnomegit-i18n'
                else:
                    user_data[uid]['restrict'] = 'gnomegit'
            else:
                user_data[uid]['restrict'] = restrict

    return user_data

# we don't expect any errors with this so we let any that occur go up
# to the top so that cron mails them out.
def remove_directory (dir):
    assert os.path.isdir (dir)
    file_list = os.listdir (dir)

    for file in file_list:
        path = os.path.join(dir, file)
        if os.path.isfile (path):
            os.remove (path)
        elif os.path.isdir (path):
            remove_directory (path)
    os.rmdir (dir)

def create_directory_structure (user_data):
    base_directory_name = tempfile.mktemp ('-sshd')
    sshd_directory_name = base_directory_name + "/sshd"
    users_directory_name = sshd_directory_name + "/users"
    os.mkdir (base_directory_name, 0700)

    try:
        os.mkdir (sshd_directory_name, 0711)
        os.mkdir (users_directory_name, 0711)

        # make a users dir
        for uid, user in user_data.iteritems():
            user_dir_name = users_directory_name + "/" + user['uid']
            authorized_keys_file = user_dir_name + "/authorized_keys"
            os.mkdir (user_dir_name, 0700)
            os.chown (user_dir_name, int(user['uidNumber']), int (user['gidNumber']))
            file = open (authorized_keys_file, "w")
            for key in user['authorizedKey']:
                restrict = user.get('restrict', None)
                if restrict:
                    file.write(RESTRICTS[restrict])
                file.write (key)
                file.write ("\n")
            file.close()
            os.chmod (authorized_keys_file, 0700)
            os.chown (authorized_keys_file, int (user['uidNumber']), int (user['gidNumber']))

        # We special case root
        if os.path.isfile ("/root/.ssh/authorized_keys"):
            user_dir_name = users_directory_name + "/root"
            authorized_keys_file = user_dir_name + "/authorized_keys"
            os.mkdir (user_dir_name, 0700)
            os.chown (user_dir_name, 0, 0)
            shutil.copy2('/root/.ssh/authorized_keys', authorized_keys_file)

    except Exception, e:
        remove_directory (base_directory_name)
        raise
    return base_directory_name


def print_user_list (description, user_list):
    if not user_list:
        return

    user_len = len (user_list)
    if user_len == 1:
        print description + " %d user:" % user_len
    else:
        print description + " %d users:" % user_len
    for user in sorted(user_list):
        print "\t%s" % user
    print

def print_comparison (initial_user_hash, post_user_hash):
    removed_users = []
    new_users = []
    changed_users = []
    # go through the list of initial
    for user, hash in initial_user_hash.iteritems():
        try:
            post_hash = post_user_hash [user]
            if post_hash != hash:
                changed_users.append (user)
            del post_user_hash [user]
        except KeyError:
            removed_users.append (user)
    for user in post_user_hash.iterkeys():
        new_users.append (user)

    print_user_list ("Added", (new_users))
    print_user_list ("Removed", (removed_users))
    print_user_list ("Changed", (changed_users))

if __name__ == '__main__':
    from optparse import OptionParser
    parser = OptionParser()
    parser.add_option("--restrict",
                      action="store", dest="restrict", default=None,
                      choices=['gnomegit', 'mango', 'rrsync', 'gnomegit-i18n'],
                      help="What type of restricted access to setup")

    parser.add_option("--gnomegit",
                      action="store_const", dest="restrict", const="gnomegit")
    parser.add_option("--rrsync",
                      action="store_const", dest="restrict", const="rrsync")
    parser.add_option("--mango",
                      action="store_const", dest="restrict", const="mango")
    parser.add_option("--translation-user",
                      action="store_const", dest="restrict", const="gnomegit-i18n")

    parser.add_option("--create-all-homedirs",
                      action="store_const", dest="homedirs", const="all")
    parser.add_option("--create-homedirs",
                      action="store_const", dest="homedirs", const="basic")

    parser.set_defaults(homedirs=None)

    (options, group_list) = parser.parse_args()

    if options.homedirs == 'all':
        user_list_homedirs = get_homedirs()
        created_users = create_home_directories(user_list_homedirs)
        print_user_list('Created home directory for', created_users)
        sys.exit(1)

    user_data = build_user_hash (group_list, restrict=options.restrict)
    if not len(user_data):
        print "ERROR: No users to create! Likely empty LDAP directory!!"
        sys.exit(1)

    if options.homedirs == 'basic':
        created_users = create_home_directories(user_data)
        print_user_list('Created home directory for', created_users)
        sys.exit(1)

    base_directory_name = create_directory_structure(user_data)

    initial_user_hash = get_md5sum_hash ()
    status = subprocess.call(['rsync', '-aq', '--delete', '%s/sshd/' % base_directory_name, '/etc/sshd/'])
    if status != 0:
        print ("Error in rsync of files:")
        try:
            remove_directory (base_directory_name)
        except IOError, e:
            print "Unable to remove directory %s\n%s" % (base_directory_name, str(e))
        sys.exit (status)
    post_user_hash = get_md5sum_hash ()
    remove_directory (base_directory_name)
    print_comparison (initial_user_hash, post_user_hash)
